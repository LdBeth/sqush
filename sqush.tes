! SQUSH.TES for TECO-64 !
0,128ET
EO - 200 "L
    @^A%Macro requires TECO-64% 13^T 10^T ^C
'
!! The original SQU.TES source cannot be directly run in TECO
!! because it is formatted with TABs which TECO treats as commands.
!! In other words, it needs to be bootstrapped.
!! This is a cleaned up version that can be directly run by TECO-64,
!! it uses new features in TECO-64 thus can not be used for other
!! TECO implementations.

!! Additional notes:
!! * Current version based on TECO-64 200.36.7
!! * Due to #21, usage of go to labels in macro R is rewrote using
!!   loop construct.
!! * TECO-64 forbids interleaved loop exit such as < D .-Z; 0A"D > '.
!! * /W switch is disabled.

!! str 9: a mask containing labels we'll use in a goto.  Each
!! character in the mask corresponds with a TECO command character
!! and controls some action the squisher takes when it runs into
!! that TECO command.  For example, if the squisher runs into
!! <NUL>, the squisher uses the first character in the 9.str mask
!! as a label to goto which handles <NUL>'s.  The mask characters
!! are:
!!
!!         1       command takes character argument
!!         A       ^A command
!!         B       delete if line is blank
!!         D       delete character from output
!!         E       E command
!!         F       F command
!!         L       lowercase char (convert to uppercase)
!!         O       optionally delete character from output
!!         T       TAB char
!!         U       ^U command
!!         V       ^^ command, leave next char as is
!!         Z       ^Z command, convert to <CARET>-Z
!!         ^       (caret) next char is really CTRL-char
!!         $       command takes string argument(s)
!!         .       (dot) pass character through w/o squishing
!!         @       the next command is '@' modified

!! Load Q-register F with SQU initialization macro.
^UF                             !! initialization macro
^D                              !! set decimal
0ED                             !! set edit mode zero
0^X                             !! set search mode zero
ET&128 "N                       !! if abort-on-error not set
        0,0XP                   !!   clear str P
'                               !! fi
0,128ET                         !! set abort-on-error
J                               !! go to beginning
< @FS%^ES%%; >                  !! remove white space in buffer
J                               !! return beginning
:@S%/%                          !! look for '/' switch
UB                              !! -> num B
QB "T                           !! if switches
        ET&64 "E                !!   if not detached
                13 ^T 10 ^T     !!     type <CR><LF>
        '                       !!   fi
'                               !! fi

!! R get Response from user
@^UR{
+0U.3                           !! num 3 <- Q-reg name on argument stack
^YX.0                           !! str 0 <- last inserted string
^YK                             !! kill display prompt
Q.3&127 "R                      !! if Q-reg name in num 3 is alphanumeric
.U.1                            !! num 1 <- current point
ZJ                              !! go to end
.U.2                            !! num 2 <- save buffer end pos

!! build a mini-macro in Q-reg 1 which will put the user's response
!! into the Q-reg we are using to return the user's response in.
@I%Q2,.X%                       !! insert text to buffer
Q.3&127@I%%                     !! insert Q-reg name
Q.2,.X.1                        !! save the inserted macro
Q.2,.K                          !! and clean up it

!! display the prompt on a new, clean, line

-1U.X <                         !! PROMPT:

13^T10^T                        !! type <CR><LF>
@!+                             !! ET does not work for TECO-64
13^T                            !! type <CR>
ET&512 "N                       !! if on scope terminal emit clear sequence
        0,1ET                   !!   inhibit type-out conversions
        27^T                    !!   type <ESC>
        1,0ET                   !!   enable type-out conversions
        0:W-4"E                 !!   if VT100 in ANSI mode
                ^^[             !!     type [
        '                       !!   fi
        ^^J^T                   !!   type J
|                               !! else (not on scope)
        10^T                    !!   type <LF>
'                               !! fi
+
.-Q.2+(0^Q) "G                  !! if anything on current line
        0T                      !!   type the line
|                               !! else
        :G.0                    !!   type str 0
        Q.2,ZT                  !!   and input so far
'                               !! fi

!! Read characters from the console & insert them into the edit buffer.

<                               !! GETCH:

^TU.0                           !! read char to num 0
Q.0-127 "E                      !! if char = <DEL>
        Z-Q.2 "N                !!   if anything been inserted
                -D              !!     backspace
        '                       !!   fi
        1;                      !!   go to PROMPT
'                               !! fi
Q.0-21 "E                       !! if char = ^U
        Q.2,ZK                  !!   clear input line
        1;                      !!   go to PROMPT
'                               !! fi
Q.0-18 "E                       !! if char = ^R
        13^T 10^T               !!   type <CR> <LF>
        :G.0                    !!   type prompt in str 0
        Q.2,ZT                  !!   type current input
        F<                      !!   go to GETCH
'                               !! fi
Q.0-26 "E                       !! if char = ^Z
        Q.2,ZK                  !!   kill input
        :%.0                    !! inc char so ^Z becomes <ESC>
'                               !! fi
Q.0-27 "E                       !! if char = <ESC>
        13^T 10^T               !!   type <CR> <LF>
        1U.X 1;                 !!   go to DONE
'                               !! fi
Q.3&128 "E                      !! if hi-bit of return Q-reg name is zero
        Q.0-10 "E               !!   if char = <LF>
                13^T            !!     display <CR>
                1U.X 1;         !!     go to DONE
        '                       !!   fi
        Q.0-13 "E               !!   if char = <CR>
                ^T^[             !!     absorb next char
                1U.X 1;         !!     go to DONE
        '                       !!   fi
'                               !! fi
Q.0@I%%                         !! insert input char to buffer
>                               !! go to GETCH

Q.X; >                          !! DONE:

M.1                             !! run macro 1 to load Q-reg w/response
Q.2,.K                          !! clean up input

Q.1J                            !! restore to original buffer position

|                               !! else (Q.3 not alphanumeric)
        :@^A%?Invalid Q-register in INPLIN%
'                               !! fi (Q.3&127 "R)
}                               !! end of ^UR

!! Check for command line switches.

!! Y short hand for read command arg
@^UY{
::@FS%:%% "S            !! if :arg
        0A@^UQ%%        !!   str Q <- arg
        D               !!   delete arg
|                       !! else
        @^UQ%Y%         !!   default "Y"
'                       !! fi
}                       !! end of ^UY

!! Check for /D "Delete CR/LF"

0,0X9                           !! clear mask in str 9
J                               !! go to beginning
:@FS%/D%% "S                    !! if /D
        MY                      !!   get arg
|                               !! else (no /D)
        QB "T                   !!   if other switches present
                @^UQ%%          !!     str Q <- ""
        |                       !!   else
                @I%Delete CR/LF (Y/N) <N>? %
                ^^QMR           !!     ask for /D
        '                       !!   fi
'                               !! fi
0QQ "A                          !! if /D is alphabetic
        0QQ&95-^^Y "E           !!   if 'y' or 'Y'
                !! load str 9 with labels for control chars, with <LF>,
                !! <CR>, and <SP> marked as D.
                !!
                !!  %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ %
                @^U9%DA.......TD..D.......U....Z...V.D%
        '                       !!   fi
'                               !! fi

!! Check for /L "Set line lengths" switch.

<                                       !! BADNUM: re-ask if :nn bad
0UO                                     !! clear num O
J                                       !!   go to beginning
:Q9 "N                                  !! if /D:Y set
        :@FS%/L%% "S                    !!   and if /L, delete it
                :@^A"%/L specified with /D, /L ignored"
                ::@FS%:%% "S            !!     if :arg
                        0A "D           !!       if arg is numberic
                                < D .-Z; 0A "D | 1; ' > !! delete nn
                        |               !!       else
                                D       !!         delete arg
                        '               !!       fi
                '                       !!     fi
        '                               !!   fi
|                                       !! else (no D:Y)
        :@FS%/L%% "S                    !!   if /L
                ::@FS%:%% "S            !!     if :arg
                        0A@^UQ%%        !!       str Q <- arg
                        0A "D           !!       if arg is numberic
                                < D .-Z; 0A "D 0A:@^UQ%% | 1; ' > !! get nn
                        |               !!       else
                                D       !!         delete arg
                        '               !!       fi
                |                       !!     else (no :arg)
                        @^UQ%Y%         !!       str Q <- "Y"
                '                       !!     fi
        |                               !!   else (no /L)
                QB "T                   !!     if other switches
                        @^UQ%%          !!       str Q <- ""
                |                       !!     else
                        @I%Set line lengths (Y for 70, N, or length) <N>? %
                        ^^QMR           !!       ask for /L
                '                       !!     fi
        '                               !!   fi
        0QQ "A                          !!   if /L is alphabetic
                0QQ&95-^^Y "E           !!     if is 'y' or 'Y'
                        !! load 9.str with labels for control chars,
                        !! with <LF>, <CR>, and <SP> marked as O.
                        !!
                        !!  %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ %
                        @^U9%DA.......TO..O.......U....Z...V.O%
                        70UD            !!       set line length to 70
                '                       !!     fi
        '                               !!   fi
        0QQ "D                          !!   if /L is numberic
                .UQ                     !!     save current pos
                ZJ                      !!     go to pos end
                GQ                      !!     put /L str in buffer
                ^SC                     !!     go to /L str begin
                \UO                     !!     put str in num O
                ^SD                     !!     clean up
                .-Z "N                  !!     if anything left over
                        ZK              !!       kill them
                        QQJ             !!       restore pos
                        F<              !!       go to BADNUM
                '                       !!     fi
                QQJ                     !!     restore pos
                QO "E                   !!     if /L is 0
                        F<              !!       go to BADNUM
                '                       !!     fi
                !! load str 9 with labels for control chars, with <LF>,
                !! <CR>, and <SP> marked as O.
                !!
                !!  %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ %
                @^U9%DA.......TO..O.......U....Z...V.O%
        '                               !!   fi
' 1; >                                  !! fi

!! Check for /B "Delete blank lines" switch

J                                       !! go to beginning
:Q9 "N                                  !! if had /D:Y
        :@FS%/B%% "S                    !!   if /B
                ::@FS%:%% "S            !!     if :arg
                        0A-^^N "E       !!       if /B:N ignore it
                                :@^A"%/B:N ignored because /D or /L on"
                        '               !!       fi
                        D               !!       delete arg
                '                       !!     fi
        '                               !!   fi
|                                       !! else (no /D:Y)
        :@FS%/B%% "S                    !!   if /B
                MY                      !!     get arg
        |                               !!   else
                QB"T                    !!     if any other switches
                        @^UQ%%          !!        str Q <- ""
                |                       !!     else
                        @I%Delete blank lines (Y/N) <N>? %
                        ^^QMR           !!       ask for /B value
                '                       !!     fi
        '                               !!   fi
        0QQ "A                          !!   if /B is alphabetic
                0QQ&95-^^Y "E           !!     if it's 'y' or 'Y'
                        !! load str 9 with labels for control chars,
                        !! with <LF> marked as B and <SP> marked as D.
                        !!
                        !!  %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ %
                        @^U9%DA.......TB..........U....Z...V.D%

                '                       !!     fi
        '                               !!   fi
'                                       !! fi

!! Supply the default labels which only deletes <NUL> and <SP>

:Q9 "E                                  !! if str 9 is empty
                                        !!   load default mask
        !!  %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ %
        @^U9%DA.......T...........U....Z...V.D%
'                                       !! fi

!! Check for /T "Delete lexical TABs and FFs" switch.

J                                       !! go to beginning
:@FS%/T%% "S                            !! if /T
        MY                              !!   get arg
|                                       !! else
        QB "T                           !!   if any other switches
                @^UQ%%                  !!     str Q <- ""
        |                               !!   else
                @I%Delete lexical TABs and FORM FEEDs (Y/N) <N>? %
                ^^QMR                   !!     ask for /T
        '                               !!   fi
'                                       !! fi
0QQ "A                                  !! if /T is alphabetic
        0QQ&95@^UQ%%                    !!   convert to uppercase
'                                       !! fi

!! if /T is "Y"

0QQ-^^Y "E              !! if /T is 'Y'
        J               !!   go to beginning
        G9              !!   load mask to buffer
        9J              !!   go to TAB entry
        D @I%O%         !!   replace by 'O'
        12J             !!   go to FF entry
        D @I%O%         !!   replace
        J 0,33X9 0,33K  !!   save mask and cleanup
'                       !! fi

!! Check for /C "Delete comments" switch.

@^UC%%                                  !! str C <- ""
J                                       !! go to beginning
:@FS%/C%% "S                            !! if /C
        MY                              !!   get arg
|                                       !! else
        QB "T                           !!   if any other switches
                @^UQ%%                  !!     str Q <- ""
        |                               !!   else
                @I%Delete comments (Y for SP/TAB, N, or set) <N>? %
                ^^QMR                   !!     ask for /C
        '                               !!   fi
'                                       !! fi
:QQ "E                                  !! if str Q empty
        @^UQ%N%                         !!   str Q <- "N"
'                                       !! fi
0QQUQ                                   !! num Q <- str Q[0]
QQ "V                                   !! if num Q lowercase
        QQ-32UQ                         !!   force uppercase
'                                       !! fi
QQ-^^N "E                               !! if /C == "N"
        :@^U9%A%                        !!   append "A" to str 9
|                                       !! else
        :@^U9%C%                        !!   append "C" to str 9
        QQ-^^Y "E                       !!   if /C == "Y"
                32@^UC%%                !!     str C <- <SP>
                9:@^UC%%                !!     append TAB to str C
        |                               !!   else
                GQ                      !!     put /C in buffer
                ^YXC                    !!     load to Q-reg C
                ^YK                     !!     clean up
        '                               !!   fi
'                                       !! fi

!! append entries for all other TECO commands to the mask in Q-reg 9

!!   %"#$%&'()*+,-./0123456789:;<=>?%
:@^U9%1..1..........................%

!!   %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_%
:@^U9%@....EF1.$...1$$.1.$.1..1..1.1^$%

!!   %`abcdefghijklmnopqrstuvwxyz{|}~ %
:@^U9%.LLLLLLLLLLLLLLLLLLLLLLLLLL....D%

!! Load Q-register 8 with potential <delim> characters

@^U8%/#*&\?()$!@%                       !! pre-load str 8
1U8                                     !! num 8 <- 1
126<                                    !! this loop appends ASCII chars
        Q8:@^U8%% %8^[                   !! ^A to ~ to str 8
   >

!! Check for /W "Watch progress" switch

@!+                                     !! does not make sense
!! no need to test ET&512
@^UW%%                                  !! clear str W
J                                       !! go to beginning
:@FS%/W%%"S                             !! if /W
        MY                              !!   get arg
|                                       !! else
        QB "T                           !!   if any other switches
                @^UQ%%                  !!     str Q <- "Y"
        |                               !!   else
                @I%Watch progress (Y/N) <N>? %
                ^^QMR                   !!     ask for /W
        '                               !!   fi
'                                       !! fi
0QQ "A                                  !! if /W is alphabetic
        0QQ&95-^^Y "E                   !!   if is 'Y' or 'y'
                @^UW/-1W/               !!     str W <- "-1W"
        '                               !!   fi
'                                       !! fi
+
!! Check for /A "Automatic mode".

@^UK%%                                  !! clear str K
J                                       !! go to beginning
:@FS%/A%%"S                             !! if /A
        MY                              !!   get arg
|                                       !! else
        QB"T                            !!   if any other switches
                @^UQ%Y%                 !!     str Q <- "Y"
        |                               !!   else
                @I/Automatic mode (Y for %, N, or set) <N>? /
                ^^QMR                   !!     ask for /A
        '                               !!   fi
'                                       !! fi
:QQ"N                                   !! if any /A val
        0QQUQ                           !!   convert /A val to ASCII
        QQ"V                            !!   if /A val lowercase
                QQ-32UQ                 !!     to uppercase
        '                               !!   fi
        QQ-^^N"N                        !!   if /A not "N"
                QQ-^^Y"E                !!     if /A == "Y"
                        ^^%@^UK%%       !!       str K <- "%"
                |                       !!     else (it's a set?)
                        GQ              !!       put /A set in edit buf
                        ^YXK            !!         load it into str K
                        ^YK             !!       clean up
                '                       !!     fi
        '                               !!   fi
'                                       !! fi

!! Check for /E "Allow adjacent ESCapes" switch.

0UH                                     !! num H <- FALSE
J                                       !! jump to beginning of buffer
:@FS%/E%%"S                             !! if "/E" found
        ::@FS%:%%"S                     !!   if ":" found
                0A@^UQ%%                !!     Q.str = arg
                D                       !!     delete arg
        |                               !!   else
                @^UQ%Y%                 !!     Q.str = "Y"
        '                               !!   fi
|                                       !! else
        QB"T                            !!   if any other switches
                @^UQ%%                  !!     Q.str = ""
        |                               !!   else
                @I%Allow adjacent ESCapes (Y/N) <N>? %
                ^^QMR                   !!     ask for /E value
        '                               !!   fi
'                                       !! fi
0QQ"A                                   !! if /E val is alphabetic
        0QQ&95-^^Y"E                    !!   if it's 'y' or 'Y'
                -1UH                    !!     H.num = -1 (TRUE)
        '                               !!   fi
'                                       !! fi

0,0XY                   !! clear get arg macro

!! Load Q-register Z with the squisher macro

@^UZ{                                   !! str Z <- squish macro
[1                                      ! save Q-reg 1                  !
0U1                                     ! clear @-modifed flag          !
:QW"N                                   ! if /W was TRUE                !
        -1,3:W^[                         !   turn on SEEALL mode         !
        0,4:W^[                          !   set no "mark" status        !
        0,5:W^[                          !   turn hold mode off          !
'                                       ! endif                         !

!! ---------------------------------------------------------------------
!! main loop start
!! ---------------------------------------------------------------------

<
!..!
@!+                                     !! /W disabled
MW                                      ! refresh scope                 !
+
!.!

ME;                                     ! break if E macro returns 0    !

0AU0                                    ! 0.num = char in buffer        !
Q0"L                                    ! if char is less than zero     !
        @O!OFFEND!                      !   end of file err             !
'                                       ! endif                         !
C                                       ! advance one character         !
Q0&128"N                                ! if char's hi bit is set       !
        Q0&127U0                        !   zero hi bit                 !
        -D                              !   delete hi bit char          !
        Q0@I%%                          !   insert zero hi bit char     !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! Use the ASCII value of the current char in 0.num as an index into the !
! labels in 9.str, and goto that label.                                 !
! --------------------------------------------------------------------- !

!DISP!                                  ! dispatch                      !
Q0Q9@^U0%%                              ! 0.str = Q0th char of 9.str    !
@O!^EQ0!                                ! and jump to it                !

! --------------------------------------------------------------------- !
! handle a lowercase character.  convert it to uppercase and process    !
! it again.                                                             !
! --------------------------------------------------------------------- !

!L!

Q0-32U0                                 ! convert to uppercase          !
-D                                      ! delete lowercase char         !
Q0@I%%                                  ! insert uppercase char         !
@O!DISP!                                ! try label for uppercase char  !

! --------------------------------------------------------------------- !
! handle '^'.  the next character is really CTRL-char.  we'll delete    !
! the "^char" construct, insert the "real" control char, and go back    !
! and process it again.  we'll watch out for inserting ^[ (<ESC>), we   !
! have to be careful about creating adjacent <ESC>'s.                   !
! --------------------------------------------------------------------- !

!^!

0A&31U0                                 ! 0.num = ^char                 !
C                                       ! skip past char                !
-2D                                     ! delete both ^ and char        !
QH"F                                    ! if no adjacent ESC's          !
        Q0-27"E                         !   if ^char is ESC             !
                0A-27"E                 !     if next char is ESC       !
                        @I%^[%           !       insert a single ESC     !
                        C               !       skip past next ESC      !
                        @O!..!          !       jump to main loop       !
                '                       !     endif                     !
                ! ----------------------------------------------------- !
                ! at this point we are trying to insert an ESC; but we  !
                ! don't know if by doing so we will inadvertently form  !
                ! two adjacent escapes.  the following code searches    !
                ! backwards for the last important character (skipping  !
                ! CF/LF's) to see if that last important character was  !
                ! also an ESC.  if it was, we'll insert a <SP> to keep  !
                ! the two ESC's lexically apart.                        !
                ! ----------------------------------------------------- !
                .US                     !     S.num = cur buf ptr       !
                0UT                     !     T.num = 0                 !
                <                       ! ----loop begin--------------- !
                        -.;             !       break if .==0           !
                        R               !       back up one char        !
                        0AUT            !       T.num = previous char   !
                        QT&128"E        !       if hi bit of char zero  !
                                QT-10"N         ! if char is not <LF>   !
                                        0;      !   break out of loop   !
                                |               ! else (it is <LF>)     !
                                        -.;     !   break if .==0       !
                                        -1A-128-13"N ! if not <CR><LF>  !
                                                0;  ! break out of loop !
                                        '       !   endif               !
                                '               ! endif                 !
                        '               !       endif                   !
                >                       ! ----loop end----------------- !
                QSJ                     !       jump to where we startd !
                QT-27"E                 !       if last char == ESC     !
                        @I% %           !         insert <SP>           !
                '                       !       endif                   !
        '                               !     endif                     !
'                                       !   endif                       !
Q0@I%%                                  ! insert ^char                  !
@O!DISP!                                ! try again                     !

! --------------------------------------------------------------------- !
! handle 'B'.  we've run into the <LF> portion of CR/LF with the /B     !
! switch (delete blank lines) set.  if there are only two chars on the  !
! current line, assume they are CR/LF and delete them.                  !
! --------------------------------------------------------------------- !

!B!

-1^Q+2"E                                ! if only 2 chars on this line  !
        -2D                             !   delete <CR><LF>             !
'                                       ! endif                         !
@O!..!                                  ! jump to main loop             !

! --------------------------------------------------------------------- !
! handle 'O'.  we've run into <LF>, <CR>, or <LF> with the /L switch    !
! set.                                                                  !
! --------------------------------------------------------------------- !

!O!

-D                                      ! delete last char              !
."N                                     ! if not at beginning of buffer !
        -1A&128"N                       !   if last char hi bit set     !
                -D                      !     delete it                 !
        '                               !   endif                       !
        .-1"G                           !   if 2 chars past buf begin   !
                -1A-10"E                !     if hi bi of last char set !
                        -2A-128-13"E    !       if 2nd last char = <CR> !
                                Q0-13"E !         if curr char is <CR>  !
                                        -2D !       delete <CR><CR>     !
                                |       !         else                  !
                                        @O!..! !    jump to main loop   !
                                '       !         endif                 !
                        '               !       endif                   !
                '                       !     endif                     !
        '                               !   endif                       !
        Q0#128@I%%                      !   insert char w/hi bit        !
        Q0-13"E                         !   if char is <CR>             !
                .-Z"E                   !     if at end of buffer       !
                        10@I%%          !       insert <LF>             !
                        R               !       back up one char        !
                '                       !     endif                     !
                0A&127-10"E             !     if curr char is <LF>      !
                        D               !       delete it               !
                '                       !     endif                     !
                10@I%%                  !   insert <LF>                 !
        '                               !   endif                       !
'                                       ! endif                         !
@O!..!                                  ! jump to main loop             !

! --------------------------------------------------------------------- !
! handle 'U'.  we've run into ^Uq.  usually, the string ^Uq is loading  !
! into Q-register q is *not* squished.  the problem with ^Uq is that it !
! is sometimes used to load a macro into a Q-register.  This macro code !
! should be squished too.  What we do is if the ^U is @-modified, and   !
! the <delim> is *not* in the "non-squishible ^U command" character set !
! in Q-register K, we assume it is a macro and should be sub-squished.  !
! Otherwise, the ^U argument is assumed to be a simple string and is    !
! not sub-squished.                                                     !
! --------------------------------------------------------------------- !

!U!

27@^U1%%                                ! 1.str = ESC (default delim)   !
.UC                                     ! C.num = current buf ptr       !
0AU0                                    ! 0.num = ^U Q-reg name         !
C                                       ! advance past Q-reg name       !
Q0-^^."E                                ! if it's .q (local Q-reg name) !
        0AU0                            !   0.num = "real" Q-reg name   !
        C                               !   advance past "."            !
'                                       ! endif                         !
Q0"V                                    ! if Q-reg name is lowercase    !
        Q0-32U0                         !   convert it to uppercase     !
        -D                              !   delete lowercase char       !
        Q0@I%%                          !   insert uppercase char       !
'                                       ! endif                         !
Q1"T                                    ! if @-modified                 !
        0A-(1A)"E                       !   if @^Uq<delim>text<delim>   !
                @O!$$!                  !     goto $$                   !
        '                               !   endif                       !
|                                       ! else                          !
        0A-27"E                         !   if ^Uq<ESC>                 !
                @O!$$!                  !     goto $$                   !
        '                               !   endif                       !
'                                       ! endif                         !
.US                                     ! S.num = current buf ptr       !
Q1"T                                    ! if @-modifed                  !
        0A@^U1%%                        !   1.str = <delim>             !
        D                               !   delete <delim>              !
'                                       ! endif                         !
:QW"N                                   ! if /W was TRUE                !
        :@S%^EQ1%"U                     !   if search for <delim> fails !
                @O!STRINGFAIL!          !     unterminated string       !
        '                               !   endif                       !
        .,4:W^[                          !   set mark status             !
        QSJ                             !   jump back to where we were  !
@!+
        MW                              !   refresh scope               !
+
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! if there are no "non-squishable ^U command" characters, you used the  !
! /A:N switch.  If this is the case, we'll have to drop into "manual"   !
! mode:  everytime we run into a ^U we'll ask if you want to squish it  !
! or not, Y or N.                                                       !
! --------------------------------------------------------------------- !

:QK"E                                   ! if no non-squishable ^U delim !
        :QW"E                           !   if /W was FALSE             !
                0T                      !     display line up to now    !
                10^T                    !     display <LF>              !
                T                       !     display rest of line      !
        '                               !   endif                       !
        7^T                             !   display <BEL>               !
        ETUQ                            !   save ET flags in Q.num      !
        ET#8#4-4ET                      !   turn on read w/o echo       !
        ^TU0                            !   read char into 0.num        !
        QQET                            !   restore ET flags            !
|                                       ! else (non-squishable delims)  !
        G1                              !   put <delim> in buf          !
        R                               !   back up one char            !
        ::@S%^EGK%"S                    !   if <delim> is non-squish    !
                -D                      !     delete <delim>            !
                        ^^NU0           !     0.num = N                 !
        |                               !   else                        !
                D                       !     delete <delim>            !
                ^^YU0                   !     0.num = Y                 !
        '                               !   endif                       !
'                                       ! endif                         !
:QW"N                                   ! if /W was TRUE                !
        0,4:W^[                          !   clear "mark" status         !
        32768W                          !   set huge # of display lines !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! at this point, 0.num will be "Y" if we are to sub-squish the ^U text  !
! --------------------------------------------------------------------- !

Q0-^^Y"E                                ! if 0.num is Y                 !
        ! ------------------------------------------------------------- !
        ! Q-register E originally holds ".-Z" (-number of chars until   !
        ! end of the buffer, when zero we're at end of buf).  The E     !
        ! macro is executed at the top of the squish loop so we break   !
        ! out of the squish loop when we reach the end of the buf. When !
        ! we recursively sub-squish a ^U string, we want the squish     !
        ! loop to break out when it reaches the end of the ^U string.   !
        ! Therefore, we'll now load Q-register E with a macro to do so. !
        !                                                               !
        !       -1UE                    E.num == -1 (continue flag)     !
        !       0A-^^<delim>"E          if we've run into <delim>       !
        !               0UE               E.num == 0 (break flag)       !
        !       '                       endif                           !
        !       QE                      push -1 or 0 on stack           !
        ! ------------------------------------------------------------- !
        [E [C [S                        !   save Q-reg's E, C, & S      !
        @^UE%-1UE0A-^^%                 !   load Q-reg E w/macro start  !
        0Q1:@^UE%%                      !   append <delim> to Q-reg E   !
        :@^UE%"E0UE'QE%                 !   append macro end to Q-reg E !
        MZ                              !   squish recursively          !
        ]S ]C ]E                        !   restore Q-reg's C, S & E    !
        "N                              !   if recursive MZ failed      !
                @O!PRIORFAIL!           !     announce it               !
        '                               !   endif                       !
        C                               !   advance past end ^U delim   !
        @O!$$$$!                        !   goto $$$$                   !
'                                       ! endif                         !
@O!$$$!                                 ! goto $$$                      !

! --------------------------------------------------------------------- !
! handle 'T'.  we've run into a TAB character, start an insert.         !
! --------------------------------------------------------------------- !

!T!

0U1                                     ! clear @-modified flag         !

! --------------------------------------------------------------------- !
! handle '$'.  we've run into I, N, O, or S: commands which take a      !
! single string argument (ie: commands which contain one <delim>).      !
! --------------------------------------------------------------------- !

!$!

27@^U1%%                                ! 1.str = ESC (default delim)   !
.UC                                     ! C.num = current buf ptr       !

! --------------------------------------------------------------------- !
! $$, entry point for commands which take two string arguments (ie:     !
! commands which contain two <delim>'s).                                !
! --------------------------------------------------------------------- !

!$$!

.US                                     ! S.num = start of text         !
Q1"T                                    ! if @-modified                 !
        0A@^U1%%                        !   1.str = <delim>             !
        D                               !   delete <delim>              !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! $$$, entry point for the ^U routine when we are not sub-squishing the !
! ^U argument, but we've already handled being @-modified.              !
! --------------------------------------------------------------------- !

!$$$!

:@S%^EQ1%"U                             ! if search for <delim> fails   !
        @O!STRINGFAIL!                  !   unterminated string         !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! $$$$, entry point for the ^U routine after we've sub-squished a ^U    !
! macro.                                                                !
! --------------------------------------------------------------------- !

!$$$$!

-D                                      ! delete trailing <delim>       !
.UT                                     ! T.num = end of text           !
27U0                                    ! 0.num = ESC (default <delim>  !

! --------------------------------------------------------------------- !
! At this point, we have to output a delimited string.                  !
!                                                                       !
!       0.num = <delim>                                                 !
!       C.num = start of command                                        !
!       S.num = start of text                                           !
!       T.num = end of text                                             !
!                                                                       !
! --------------------------------------------------------------------- !

!AA!

Q0@^U0%%                                ! 0.str = <delim> char          !
QT-QS"G                                 ! if string is not-empty        !
        QSJ                             !   jump to start of string     !
        .,.+QT-QS:@FB%^EQ0%"S           !   if <delim> is in string     !
                ! ----------------------------------------------------- !
                ! find a <delim> we can use, one which is *not* already !
                ! in the string.                                        !
                ! ----------------------------------------------------- !
                G8                      !     put 8.str into buf        !
                ^Y:X1                   !     put 8.str into 1.str      !
                ^YK                     !     kill 8.str from buf       !
                0U0                     !     clear 0.num               !
                <                       ! ----loop begin--------------- !
                        Q0Q1@^U0%%      !       0.str = Q0th char of Q1 !
                        QSJ             !       jump to start of text   !
                        .,.+QT-QS@FB%^EQ0%; !   break if search fails   !
                        %0-:Q8"E        !       if next char last char  !
                                @O!NOQUOTE!     ! can't find " char     !
                        '               !       endif                   !
                >                       ! ----loop end----------------- !
                Q0Q1U0                  !     0.num = <delim> to use    !
                QSJ                     !     jump to start of string   !
                Q0@I%%                  !     insert <delim>            !
                QC-1J                   !     jump before command       !
                @I%@%                   !     insert @                  !
                2%T^[                    !     T.num (end of text) += 2  !
                ! ----------------------------------------------------- !
        '                               !   endif                       !
'                                       ! endif                         !
QTJ                                     ! jump to end of string         !
Q0@I%%                                  ! insert <delim>                !
0U1                                     ! clear @-modified flag         !
@O!..!                                  ! jump to main loop             !

! --------------------------------------------------------------------- !
! handle '1'.  we've run into ", %, G, M, Q, U, X, [, or ].  For ", the !
! next character is a conditional execution command.  For everything    !
! else, the next character is a Q-register name.  In either case, if    !
! the next char is lowercase, we uppercase it; otherwise, we fall       !
! through to the 'V' code below which simply advances past the char.    !
! --------------------------------------------------------------------- !

!1!

0A-^^."E                                ! if it's .q (local Q-reg name) !
        C                               !   advance past "."            !
'                                       ! endif                         !
0A"V                                    ! if lowercase                  !
        0A-32U0                         !   convert to uppercase        !
        D                               !   delete lowercase char       !
        Q0@I%%                          !   insert uppercase char       !
        @O!.!                           !   goto .                      !
'                                       ! endif                         !
! ... fall through ...!

! --------------------------------------------------------------------- !
! handle 'V'.  we've run into <CTRL>-^, simply skip it                  !
! --------------------------------------------------------------------- !

!V!

C                                       ! simply advance past it        !
@O!.!                                   ! goto .                        !

! --------------------------------------------------------------------- !
! handle '@'.  the following command is @ modified, set a flag in 1.num !
! so we know to look for the alternate delimiter characters.            !
!                                                                       !
! even though <delim> characters will be specified along with the '@'   !
! command, we'll try to use ESC whenever possible and convert the @     !
! modified command back into a "normally" delimited command.            !
! --------------------------------------------------------------------- !

!@!

-1U1                                    ! set @-modified flag           !
! ...fall through ... !

! --------------------------------------------------------------------- !
! handle 'D'.  delete the character from the output file                !
! --------------------------------------------------------------------- !

!D!

-D                                      ! delete last character         !
@O!.!

! --------------------------------------------------------------------- !
! handle 'F'.  we've run into a F', F<. F>, F|, FB, FC, FD, FK, FN, FR, !
! FS, or F_ command.                                                    !
! --------------------------------------------------------------------- !

!F!

27@^U1%%                                ! 1.str = ESC (default delim)   !
.UC                                     ! C.num = current buf ptr       !
0AU0                                    ! 0.num = 2nd command char      !
C                                       ! advance past 2nd cmd char     !
Q0"V                                    ! if 2nd cmd char is lowercase  !
        Q0-32U0                         !   convert it to uppercase     !
        -D                              !   delete lowercase char       !
        Q0@I%%                          !   insert uppercase char       !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! the FB and FR commands take a single string argument, goto $$         !
! the FC, FS, FN, and F_ commands take two string arguments, goto F$$   !
!                                                                       !
! ???What about FD and FK taking 1 string argument                      !
! --------------------------------------------------------------------- !

Q0-^^B"E                                ! if it's FB                    !
        @O!$$!                          !   goto $$                     !
'                                       ! endif                         !
Q0-^^C"E                                ! if it's FC                    !
        @O!F$$!                         !   goto F$$                    !
'                                       ! endif                         !
Q0-^^R"E                                ! if it's FR                    !
        @O!$$!                          !   goto $$                     !
'                                       ! endif                         !
Q0-^^S"E                                ! if it's FS                    !
        @O!F$$!                         !   goto F$$                    !
'                                       ! endif                         !
Q0-^^N"E                                ! if it's FN                    !
        @O!F$$!                         !   goto F$$                    !
'                                       ! endif                         !
Q0-^^_"E                                ! if it's F_                    !
        @O!F$$!                         !   goto F$$                    !
'                                       ! endif                         !
@O!.!

! --------------------------------------------------------------------- !
! handle FC, FS, FN, and F_ commands which take two string arguments,   !
! there are three possible formats for these commands:                  !
!                                                                       !
!       Fx <delim> <delim>                                              !
!       Fx text <delim> <delim>                                         !
!       Fx text1 <delim> text2 <delim>                                  !
!                                                                       !
! we first have to find the starting and ending points of the text      !
! arguments.  we set S.num to be the start of text1, we look for the    !
! 1st <delim>, delete it, and set T.num to be the start of text2.  we   !
! then look for the 2nd <delim>, delete it, and set U.num to be the     !
! end of text2.                                                         !
!                                                                       !
! if S.num == T.num & T.num == U.num, then we have: FS$$                !
! if S.num <> T.num & T.num == U.num, then we have: FStext$$            !
! if S.num <> T.num & T.num <> U.num, then we have: FStext1$text2       !
! --------------------------------------------------------------------- !

!F$$!

.US                                     ! S.num = start of text1        !
27@^U1%%                                ! 1.str = ESC (default delim)   !
Q1"T                                    ! if @-modified                 !
        0A@^U1%%                        !   1.str = <delim>             !
        D                               !   delete <delim>              !
'                                       ! endif                         !
:@S%^EQ1%"U                             ! if search for 1st delim fails !
        @O!STRINGFAIL!                  !   unterminated string         !
'                                       ! endif                         !
-D                                      ! delete 1st <delim>            !
.UT                                     ! T.num = start of text2        !
:@S%^EQ1%"U                             ! if search for 2nd delim fails !
        @O!STRINGFAIL!                  !   unterminated string         !
'                                       ! endif                         !
-D                                      ! delete 2nd <delim>            !
.UU                                     ! U.num = end of text2          !
QH"T                                    ! if allow adjacent escapes     !
        27U0                            !   0.num = ESC                 !
        Q0@^U0%%                        !   0.str = ESC                 !
        QU-QS"G                         !   if we have text1 & text2    !
                QSJ                     !     jump to start of text1    !
                .,.+QU-QS:@FB%^EQ0%"U   !     if search for ESC fails   !
                        @O!F0!          !       use ESC as <delim>      !
                '                       !     endif                     !
        |                               !   else (no text arguments)    !
                @O!F0!                  !     use ESC as DELIM          !
        '                               !   endif                       !
|                                       ! else (don't allow adjacent $) !
        QU-QT"G                         !   if we have text2            !
                27U0                    !     0.num = ESC               !
                Q0@^U0%%                !     0.str = ESC               !
                QSJ                     !     jump to start of text1    !
                .,.+QU-QS:@FB%^EQ0%"U   !     if search for ESC fails   !
                        @O!F0!          !       done w/F                !
                '                       !     endif                     !
        '                               !   endif                       !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! if we reach this point, there is a danger of putting adjacent ESC's   !
! in the output.  we will try to find a character that's not in the     !
! string we're delimiting and use that as a <delim> character instead   !
! of ESC.  basically, we search "text1text2" looking for each character !
! in G8, trying to find a delimiter char that's not already in the      !
! string.                                                               !
! --------------------------------------------------------------------- !

G8                                      ! put 8.str into buf            !
^Y:X1                                   ! put 8.str into 1.str          !
^YK                                     ! kill 8.str from buf           !
0U0                                     ! 0.num = 0                     !
<                                       ! loop begin------------------- !
        Q0Q1@^U0%%                      !   0.str = 0.num'th char of Q1 !
        QSJ                             !   jump to start of text1      !
        .,.+QU-QS@FB%^EQ0%;             !   break if 0.str search fails !
        %0-:Q8"E                        !   inc 0.num, if end of 8.str  !
                @O!NOQUOTE!             !     can't find " char         !
        '                               !   endif                       !
>                                       ! loop end--------------------- !

! --------------------------------------------------------------------- !
! at this point, we've found our <delim> char, it's index is in 0.num   !
! --------------------------------------------------------------------- !

Q0Q1U0                                  ! 0.num = Q0th char of Q1       !
QSJ                                     ! jump to start of text1        !
Q0@I%%                                  ! insert <delim>                !
QC-1J                                   ! jump 1 char before F command  !
@I%@%                                   ! insert @                      !
2%T^[                                    ! T.num (end of text1) += 2     !
2%U^[                                    ! U.num (end of text2) += 2     !

!F0!

QTJ                                     ! jump to end of text1          !
Q0@I%%                                  ! insert <delim>                !
QU-QTC                                  ! advance to end of text2       !
Q0@I%%                                  ! insert <delim>                !
0U1                                     ! clear @-modified flag         !
@O!..!                                  ! jump to main loop             !

! --------------------------------------------------------------------- !
! handle 'A'.  we've run into ^Atext^A or @^A/text/.  This is also the  !
! entry point for the 'C' routine:  if we're not deleting the comment   !
! we handle <exclamation-point>comment<exclamation-point> just like     !
! ^Atest^A.                                                             !
! --------------------------------------------------------------------- !

!A!

Q0@^U1%%                                ! 1.str = ^A or exclamation pt. !
.UC                                     ! C.num = start of text         !
.US                                     ! S.num = start of text         !
Q1"T                                    ! if @-modified                 !
        0A@^U1%%                        !   1.str = <delim>             !
        D                               !   delete <delim>              !
'                                       ! endif                         !
:@S%^EQ1%"U                             ! if search for <delim> fails   !
        @O!STRINGFAIL!                  !   unterminated string         !
'                                       ! endif                         !
-D                                      ! delete second <delim>         !
.UT                                     ! T.num = end of text           !
@O!AA!                                  ! goto AA                       !

! --------------------------------------------------------------------- !
! handle 'C'.  we've run into an exclamation point with the /C switch   !
! set.  Q-register C contains the special comment delimiter characters. !
! --------------------------------------------------------------------- !

!C!

::@S%^EGC%"U                            ! if not special comment delim  !
        @O!A!                           !   handle like ^Astring^A      !
'                                       ! endif                         !
R                                       ! back up past special <delim>  !
.UC                                     ! C.num = current buf ptr       !
Q0@^U1%%                                ! 1.str = exclamation point     !
Q1"T                                    ! if @-modified                 !
        0A@^U1%%                        !   1.str = <delim>             !
        D                               !   delete <delim>              !
'                                       ! endif                         !
:@S%^EQ1%"U                             ! if search for <delim> failed  !
        @O!STRINGFAIL!                  !   unterminated string         !
'                                       ! endif                         !
QC-1,.K                                 ! kill entire comment           !
0U1                                     ! clear @-modified flag         !
@O!..!                                  ! jump to main loop             !

! --------------------------------------------------------------------- !
! handle 'E'.  we've run into an E command.                             !
! --------------------------------------------------------------------- !

!E!

27@^U1%%                                ! 1.str = ESC (default delim)   !
.UC                                     ! C.num = current buf ptr       !
0AU0                                    ! 0.num = 2nd command char      !
C                                       ! advance past 2nd cmd char     !
Q0"V                                    ! if 2nd cmd char is lowercase  !
        Q0-32U0                         !   convert to uppercase        !
        -D                              !   delete lowercase char       !
        Q0@I%%                          !   insert uppercase char       !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! the EB, EG, EI, EN, ER, EW, E_ commands take a string argument, they  !
! have to be passed to the $$ routine.                                  !
! ???What about EL, EQq, EZ, and E%q taking a string argument           !
! --------------------------------------------------------------------- !

Q0-^^B"E                                ! if it's EB                    !
        @O!$$!                          !   goto $$                     !
'                                       ! endif                         !
Q0-^^G"E                                ! if it's EG                    !
        @O!$$!                          !   goto $$                     !
'                                       ! endif                         !
Q0-^^I"E                                ! if it's EI                    !
        @O!$$!                          !   goto $$                     !
'                                       ! endif                         !
Q0-^^N"E                                ! if it's EN                    !
        @O!$$!                          !   goto $$                     !
'                                       ! endif                         !
Q0-^^R"E                                ! if it's ER                    !
        @O!$$!                          !   goto $$                     !
'                                       ! endif                         !
Q0-^^W"E                                ! if it's EW                    !
        @O!$$!                          !   goto $$                     !
'                                       ! endif                         !
Q0-^^_"E                                ! if it's E_                    !
        @O!$$!                          !   goto $$                     !
'                                       ! endif                         !
@O!.!

! --------------------------------------------------------------------- !
! handle 'Z'.  we've run into a ^Z, replace it with <CARET>-Z           !
! --------------------------------------------------------------------- !

!Z!

-D                                      ! delete <CTRL>-Z               !
@I%^Z%                                  ! insert <CARET>-Z              !
@O!..!                                  ! jump to main loop             !

>                                       ! main loop end---------------- !

! --------------------------------------------------------------------- !
! At this point, everything should be squished and Q1 will be -1 if     !
! an error occurred, or 0 if everything is OK.                          !
! --------------------------------------------------------------------- !

Q1"T                                    ! if error flag                 !
        @^U1%Trailing, pending @%       !                               !
        @O!ERROR!                       !   goto error display          !
'                                       ! endif                         !
0U1                                     ! clear Z-macro return value    !

! --------------------------------------------------------------------- !
! the only way the following error reporting code is executed is if we  !
! jump to a label inside of it.  if we arrive here by any other means   !
! then things are OK, skip down to the "endif".                         !
! --------------------------------------------------------------------- !

0"N                                     ! skip the following code       !
!OFFEND!
        @^U1%End of buffer while sub-squishing%
        @O!ERROR!

!NOQUOTE!
        @^U1%Can't find a quote character%
        @O!SETPOS!

!PRIORFAIL!
        @^U1%Prior recursion level failed%
        @O!SETPOS!

!STRINGFAIL!
        @^U1%Unterminated string%

! --------------------------------------------------------------------- !
! the following code finishes building an error string in Q-register 1. !
! 1.str already contains the type of error, this code appends the       !
! position where the error occurred and the line before and after the   !
! error, like so:                                                       !
!                                                                       !
!       <error message> from squished .=<error position>                !
!       <line up to error>|                                             !
!                          |<line after error>                          !
!                                                                       !
! --------------------------------------------------------------------- !

!SETPOS!
        :@^U1% from squished .=%        !   append msg to 1.str         !
        QC\                             !   position in C.num to buf    !
        ^Y:X1                           !   append position in buf      !
        ^YK                             !   delete position from buf    !
        13:@^U1%%                       !   append <CR>                 !
        10:@^U1%%                       !   append <LF>                 !
        QCJ                             !   jump to where error starts  !
        0^Q+.,.:X1                      !   append line up to error     !
        ^^|:@^U1%%                      !   append |                    !
        10:@^U1%%                       !   append <LF>                 !
        ^^|:@^U1%%                      !   append |                    !
        .,^Q+.:X1                       !   append rest of line         !

!ERROR!
        ZJ                              !  jump to buf end              !
@!+
        MW                              !  refresh scope                !
        0,0XW                           !  clear W.str (/W switch)      !
+
        7^T                             !  sound bell                   !
        ^^?^T                           !  display "?"                  !
        :G1                             !  display 1.str                !
        7^T                             !  sound bell                   !
        13^T                            !  display <CR>                 !
        10^T                            !  display <LF>                 !
        -1U1                            !  set Z-macro return to -1     !
'                                       ! endif                         !
Q1                                      ! push Z-macro return val       !
]1                                      ! restore Q-reg 1               !
}                                       !! end of ^UZ

^[^[
