! SQUSH.TES for TECO-64 !
0,128ET
EO - 200 "L
    @^A%Macro requires TECO-64% 13^T 10^T ^C
'
!! The original SQU.TES source cannot be directly run in TECO
!! because it is formatted with TABs which TECO treats as commands.
!! In other words, it needs to be bootstrapped.
!! This is a cleaned up version that can be directly run by TECO-64,
!! it uses new features in TECO-64 thus can not be used for other
!! TECO implementations.

!! Additional notes:
!! * Current version based on TECO-64 200.36.7
!! * Due to #21, usage of go to labels in macro R is rewrote using
!!   loop construct.
!! * TECO-64 forbids interleaved loop exit such as < D .-Z; 0A"D > '.
!! * /W switch is disabled.
!! * /C switch is altered, now the syntax for special char set is:
!!     /C?sepcial char set?
!!   where the ? can be replace by any delim. The char set will
!!   be appended to the default SP/TAB char set. Strpping of
!!   alternative comment form would always happen.
!! * New switch /P for handle paired delimiter, accepting
!!   arg Y or N.
!! * Special treatment to ^Z is disabled.
!! * Removed undefined macro P.

!! n B: TRUE if any command line switches were present.
!!
!! n C: the buffer pointer while squishing things for error
!! reporting purposes.
!!
!! n H: TRUE (-1) if we are allowing adjacent escapes
!!
!! str 9: a mask containing labels we'll use in a goto.  Each
!! character in the mask corresponds with a TECO command character
!! and controls some action the squisher takes when it runs into
!! that TECO command.  For example, if the squisher runs into
!! <NUL>, the squisher uses the first character in the 9.str mask
!! as a label to goto which handles <NUL>'s.  The mask characters
!! are:
!!
!!         1       command takes character argument
!!         A       ^A command
!!         B       delete if line is blank
!!         D       delete character from output
!!         E       E command
!!         F       F command
!!         L       lowercase char (convert to uppercase)
!!         O       optionally delete character from output
!!         T       TAB char
!!         U       ^U command
!!         V       ^^ command, leave next char as is
!!         Z       ^Z command, convert to <CARET>-Z
!!         ^       (caret) next char is really CTRL-char
!!         $       command takes string argument(s)
!!         .       (dot) pass character through w/o squishing
!!         @       the next command is '@' modified

!! Load Q-register F with SQU initialization macro.
^UF                             !! initialization macro
^D                              !! set decimal
0ED                             !! set edit mode zero
0^X                             !! set search mode zero
0,128ET                         !! set abort-on-error
J                               !! go to beginning
:@S%/%                          !! look for '/' switch
UB                              !! -> num B
QB "T                           !! if switches
        R                       !!   back one char
|                               !! else
        ZJ                      !!   go to pos end
'                               !! fi
0,.X.F                          !!   protect file names
0,.K                            !!   leave only switches


!! R get Response from user
@^UR{
^YX.0                           !! str 0 <- last inserted string
^YK                             !! kill display prompt
.U.1                            !! num 1 <- current point
ZJ                              !! go to end
.U.2                            !! num 2 <- save buffer end pos

!! display the prompt on a new, clean, line

-1U.X <                         !! PROMPT:

13^T10^T                        !! type <CR><LF>
@!+                             !! ET does not work for TECO-64
13^T                            !! type <CR>
ET&512 "N                       !! if on scope terminal emit clear sequence
        0,1ET                   !!   inhibit type-out conversions
        27^T                    !!   type <ESC>
        1,0ET                   !!   enable type-out conversions
        0:W-4"E                 !!   if VT100 in ANSI mode
                ^^[             !!     type [
        '                       !!   fi
        ^^J^T                   !!   type J
|                               !! else (not on scope)
        10^T                    !!   type <LF>
'                               !! fi
+
.-Q.2+(0^Q) "G                  !! if anything on current line
        0T                      !!   type the line
|                               !! else
        :G.0                    !!   type str 0
        Q.2,ZT                  !!   and input so far
'                               !! fi

!! Read characters from the console & insert them into the edit buffer.

<                               !! GETCH:

^TU.0                           !! read char to num 0
Q.0-127 "E                      !! if char = <DEL>
        Z-Q.2 "N                !!   if anything been inserted
                -D              !!     backspace
        '                       !!   fi
        0;                      !!   go to PROMPT
'                               !! fi
Q.0-21 "E                       !! if char = ^U
        Q.2,ZK                  !!   clear input line
        0;                      !!   go to PROMPT
'                               !! fi
Q.0-18 "E                       !! if char = ^R
        13^T 10^T               !!   type <CR> <LF>
        :G.0                    !!   type prompt in str 0
        Q.2,ZT                  !!   type current input
        F<                      !!   go to GETCH
'                               !! fi
Q.0-26 "E                       !! if char = ^Z
        Q.2,ZK                  !!   kill input
        :%.0                    !! inc char so ^Z becomes <ESC>
'                               !! fi
Q.0-27 "E                       !! if char = <ESC>
        13^T 10^T               !!   type <CR> <LF>
        1U.X 0;                 !!   go to DONE
'                               !! fi
Q.0-10 "E                       !!   if char = <LF>
        13^T                    !!     display <CR>
        1U.X 0;                 !!     go to DONE
'                               !!   fi
Q.0@I%%                         !! insert input char to buffer
>                               !! go to GETCH

Q.X; >                          !! DONE:

Q.2,.XQ                         !! load Q-reg w/response
Q.2,.K                          !! clean up input

Q.1J                            !! restore to original buffer position

}                               !! end of ^UR

!! Check for command line switches.

!! Y short hand for read command arg
@^UY{
::@FS%:%% "S            !! if :arg
        0A@^UQ%%        !!   str Q <- arg
        D               !!   delete arg
|                       !! else
        @^UQ%Y%         !!   default "Y"
'                       !! fi
}                       !! end of ^UY

!! Check for /D "Delete CR/LF"

0,0X9                           !! clear mask in str 9
J                               !! go to beginning
:@FS%/D%% "S                    !! if /D
        MY                      !!   get arg
|                               !! else (no /D)
        QB "T                   !!   if other switches present
                @^UQ%%          !!     str Q <- ""
        |                       !!   else
                @I%Delete CR/LF (Y/N) <N>? %
                MR              !!     ask for /D
        '                       !!   fi
'                               !! fi
0QQ "A                          !! if /D is alphabetic
        0QQ&95-^^Y "E           !!   if 'y' or 'Y'
                !! load str 9 with labels for control chars, with <LF>,
                !! <CR>, and <SP> marked as D.
                !!
                !!  %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ %
                @^U9%DA.......TD..D.......U........V.D%
        '                       !!   fi
'                               !! fi

!! Check for /L "Set line lengths" switch.

<                               !! BADNUM: re-ask if :nn bad
0UO                             !! clear num O
J                               !!   go to beginning
:@FS%/L%% "S                    !! if /L
        ::@FS%:%% "S            !!   if :arg
                0A@^UQ%%        !!     str Q <- arg
                0A "D           !!     if arg is numberic
                        < D .-Z; 0A "D 0A:@^UQ%% | 0; ' > !! get nn
                |               !!     else
                        D       !!       delete arg
                '               !!     fi
        |                       !!   else (no :arg)
                @^UQ%Y%         !!     str Q <- "Y"
        '                       !!   fi
        :Q9 "N                  !!   if /D:Y set
                :@^A"%/L specified with /D, /L ignored"
                0;              !!     go to EXIT
        '                       !!   fi
|                               !! else (no /L)
        QB "T                   !!   if other switches
                @^UQ%%          !!     str Q <- ""
        |                       !!   else
                @I%Set line lengths (Y for 70, N, or length) <N>? %
                MR              !!     ask for /L
        '                       !!   fi
'                               !! fi
0QQ "A                          !! if /L is alphabetic
        0QQ&95-^^Y "E           !!   if is 'y' or 'Y'
                !! load 9.str with labels for control chars,
                !! with <LF>, <CR>, and <SP> marked as O.
                !!
                !!  %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ %
                @^U9%DA.......TO..O.......U........V.O%
                70UD            !!     set line length to 70
        '                       !!   fi
'                               !! fi
0QQ "D                          !! if /L is numberic
        .UQ                     !!   save current pos
        ZJ                      !!   go to pos end
        GQ                      !!   put /L str in buffer
        ^SC                     !!   go to /L str begin
        \UO                     !!   put str in num O
        ^SD                     !!   clean up
        .-Z "N                  !!   if anything left over
                ZK              !!     kill them
                QQJ             !!     restore pos
                F<              !!     go to BADNUM
        '                       !!   fi
        QQJ                     !!   restore pos
        QO "E                   !!   if /L is 0
                F<              !!     go to BADNUM
        '                       !!   fi
        !! load str 9 with labels for control chars, with <LF>,
        !! <CR>, and <SP> marked as O.
        !!
        !!  %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ %
        @^U9%DA.......TO..O.......U........V.O%
'                               !!   fi
0; >                            !! EXIT:

!! Check for /B "Delete blank lines" switch

J                                       !! go to beginning
:Q9 "N                                  !! if had /D:Y
        :@FS%/B%% "S                    !!   if /B
                ::@FS%:%% "S            !!     if :arg
                        0A-^^N "E       !!       if /B:N ignore it
                                :@^A"%/B:N ignored because /D or /L on"
                        '               !!       fi
                        D               !!       delete arg
                '                       !!     fi
        '                               !!   fi
|                                       !! else (no /D:Y)
        :@FS%/B%% "S                    !!   if /B
                MY                      !!     get arg
        |                               !!   else
                QB "T                   !!     if any other switches
                        @^UQ%%          !!        str Q <- ""
                |                       !!     else
                        @I%Delete blank lines (Y/N) <N>? %
                        MR              !!       ask for /B value
                '                       !!     fi
        '                               !!   fi
        0QQ "A                          !!   if /B is alphabetic
                0QQ&95-^^Y "E           !!     if it's 'y' or 'Y'
                        !! load str 9 with labels for control chars,
                        !! with <LF> marked as B and <SP> marked as D.
                        !!
                        !!  %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ %
                        @^U9%DA.......TB..........U........V.D%

                '                       !!     fi
        '                               !!   fi
'                                       !! fi

!! Supply the default labels which only deletes <NUL> and <SP>

:Q9 "E                                  !! if str 9 is empty
                                        !!   load default mask
        !!  %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ %
        @^U9%DA.......T...........U........V.D%
'                                       !! fi

!! Check for /T "Delete lexical TABs and FFs" switch.

J                                       !! go to beginning
:@FS%/T%% "S                            !! if /T
        MY                              !!   get arg
|                                       !! else
        QB "T                           !!   if any other switches
                @^UQ%%                  !!     str Q <- ""
        |                               !!   else
                @I%Delete lexical TABs and FORM FEEDs (Y/N) <N>? %
                MR                      !!     ask for /T
        '                               !!   fi
'                                       !! fi
0QQ "A                                  !! if /T is alphabetic
        0QQ&95@^UQ%%                    !!   convert to uppercase
'                                       !! fi

!! if /T is "Y"

0QQ-^^Y "E              !! if /T is 'Y'
        J               !!   go to beginning
        G9              !!   load mask to buffer
        9J              !!   go to TAB entry
        D @I%O%         !!   replace by 'O'
        12J             !!   go to FF entry
        D @I%O%         !!   replace
        J 0,33X9 0,33K  !!   save mask and cleanup
'                       !! fi

!! Check for /C "Delete comments" switch.

@^UC%%                                  !! str C <- ""
J                                       !! go to beginning
:@FS%/C%% "S                            !! if /C
        0A@^UQ%%                        !!   save delim char
        D .UQ                           !!   advance and save pos
        :@FS%^EQQ%% "S                  !!   if search delim
                QQ,.XQ                  !!     load set to str Q
                QQ,.K                   !!     kill arg
        |                               !!   else
                :@^A"Incorrect syntax for /C"
                @^UQ%%                  !!     clear str Q
        '                               !!   fi
|                                       !! else
        QB "T                           !!   if any other switches
                @^UQ%%                  !!     str Q <- ""
        |                               !!   else
                @I%Special comment delimters <SP/TAB>? %
                MR                      !!     ask for /C
        '                               !!   fi
'                                       !! fi
@^UC% %                                 !! str C <- <SP>
9:@^UC%%                                !! append TAB to str C
:QQ "G                                  !! if has input
        GQ                              !!   put /C in buffer
        ^Y:XC                           !!   load to Q-reg C
        ^YK                             !!   clean up
'                                       !! fi

!! append entries for all other TECO commands to the mask in Q-reg 9

!!   %!"#$%&'()*+,-./0123456789:;<=>?%
:@^U9%C1..1..........................%

!!   %@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_%
:@^U9%@....EF1.$...1$$.1.$.1..1..1.1^$%

!!   %`abcdefghijklmnopqrstuvwxyz{|}~ %
:@^U9%.LLLLLLLLLLLLLLLLLLLLLLLLLL....D%

!! Check for /P "Paired Delimiter" switch

!! Load Q-register 8 with potential <delim> characters

@^U8%/#*&\?()$!@%               !! frequently used char
1U8                             !! num 8 <- 1
126<                            !! appends all ASCII chars
        Q8:@^U8%% %8^[
>
0UP                             !! num P <- FALSE
J                               !! go to beginning
:@FS%/P%% "S                    !! if /P
        MY                      !!   get arg
|                               !! else (no /P)
        QB "T                   !!   if other switches present
                @^UQ%%          !!     str Q <- ""
        |                       !!   else
                @I%Use paired delimiter (Y/N) <N>? %
                MR              !!     ask for /P
        '                       !!   fi
'                               !! fi
0QQ "A                          !! if /P is alphabetic
        0QQ&95-^^Y "E           !!   if 'y' or 'Y'
                -1UP            !!     num P <- TRUE
                @^UP%(<[{%      !!     str P <- left parenthese chars
                ZJ .U8          !!     go to end of buffer and save
                G8 Q8J          !!     unpack str 8 and go to start
                < @FS%^EGP%%; > !!     remove left parens
                Q8,ZX8          !!     reload str 8
                Q8,ZK           !!     clean up
                @^UP%}]>)%      !!     set to opposite parens
        '                       !!   fi
'                               !! fi

!! Check for /W "Watch progress" switch

@!+                                     !! does not make sense
!! no need to test ET&512
@^UW%%                                  !! clear str W
J                                       !! go to beginning
:@FS%/W%%"S                             !! if /W
        MY                              !!   get arg
|                                       !! else
        QB "T                           !!   if any other switches
                @^UQ%%                  !!     str Q <- "Y"
        |                               !!   else
                @I%Watch progress (Y/N) <N>? %
                MR                      !!     ask for /W
        '                               !!   fi
'                                       !! fi
0QQ "A                                  !! if /W is alphabetic
        0QQ&95-^^Y "E                   !!   if is 'Y' or 'y'
                @^UW/-1W/               !!     str W <- "-1W"
        '                               !!   fi
'                                       !! fi
+
!! Check for /A "Automatic mode".

@^UK%%                                  !! clear str K
J                                       !! go to beginning
:@FS%/A%%"S                             !! if /A
        MY                              !!   get arg
|                                       !! else
        QB"T                            !!   if any other switches
                @^UQ%Y%                 !!     str Q <- "Y"
        |                               !!   else
                @I/Automatic mode (Y for %, N, or set) <N>? /
                MR                      !!     ask for /A
        '                               !!   fi
'                                       !! fi
:QQ"N                                   !! if any /A val
        0QQUQ                           !!   convert /A val to ASCII
        QQ"V                            !!   if /A val lowercase
                QQ-32UQ                 !!     to uppercase
        '                               !!   fi
        QQ-^^N"N                        !!   if /A not "N"
                QQ-^^Y"E                !!     if /A == "Y"
                        ^^%@^UK%%       !!       str K <- "%"
                |                       !!     else (it's a set?)
                        GQ              !!       put /A set in edit buf
                        ^YXK            !!         load it into str K
                        ^YK             !!       clean up
                '                       !!     fi
        '                               !!   fi
'                                       !! fi

!! Check for /E "Allow adjacent ESCapes" switch.

0UH                                     !! num H <- FALSE
J                                       !! jump to beginning of buffer
:@FS%/E%%"S                             !! if "/E" found
        ::@FS%:%%"S                     !!   if ":" found
                0A@^UQ%%                !!     Q.str = arg
                D                       !!     delete arg
        |                               !!   else
                @^UQ%Y%                 !!     Q.str = "Y"
        '                               !!   fi
|                                       !! else
        QB"T                            !!   if any other switches
                @^UQ%%                  !!     Q.str = ""
        |                               !!   else
                @I%Allow adjacent ESCapes (Y/N) <N>? %
                MR                      !!     ask for /E value
        '                               !!   fi
'                                       !! fi
0QQ"A                                   !! if /E val is alphabetic
        0QQ&95-^^Y"E                    !!   if it's 'y' or 'Y'
                -1UH                    !!     H.num = -1 (TRUE)
        '                               !!   fi
'                                       !! fi

0,0XY                   !! clear get arg macro

< @FS%^ES%%; >          !! remove spaces
Z "G                    !! if command switches are not consumed
        :@^A%Command switches not fully consumed%
'                       !! fi
HK                      !! clear buffer
G.F                     !! retrive file names

!! Load Q-register Z with the squisher macro

@^UZ{                                   !! str Z <- squish macro
[1                                      ! save Q-reg 1                  !
0U1                                     ! clear @-modifed flag          !
@!+
:QW"N                                   ! if /W was TRUE                !
        -1,3:W^[                         !   turn on SEEALL mode         !
        0,4:W^[                          !   set no "mark" status        !
        0,5:W^[                          !   turn hold mode off          !
'                                       ! endif                         !
+

!! ---------------------------------------------------------------------
!! main loop start
!! ---------------------------------------------------------------------

<
@!+                                     !! /W disabled
MW                                      ! refresh scope                 !
+
!.!

ME;                                     ! break if E macro returns 0    !

0AU0                                    ! 0.num = char in buffer        !
Q0"L                                    ! if char is less than zero     !
        @O!OFFEND!                      !   end of file err             !
'                                       ! endif                         !
C                                       ! advance one character         !
Q0&128"N                                ! if char's hi bit is set       !
        Q0&127U0                        !   zero hi bit                 !
        -D                              !   delete hi bit char          !
        Q0@I%%                          !   insert zero hi bit char     !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! Use the ASCII value of the current char in 0.num as an index into the !
! labels in 9.str, and goto that label.                                 !
! --------------------------------------------------------------------- !

!DISP!                                  ! dispatch                      !
Q0Q9@^U0%%                              ! 0.str = Q0th char of 9.str    !
@O!^EQ0!                                ! and jump to it                !

! --------------------------------------------------------------------- !
! handle a lowercase character.  convert it to uppercase and process    !
! it again.                                                             !
! --------------------------------------------------------------------- !

!L!

Q0-32U0                                 ! convert to uppercase          !
-D                                      ! delete lowercase char         !
Q0@I%%                                  ! insert uppercase char         !
@O!DISP!                                ! try label for uppercase char  !

! --------------------------------------------------------------------- !
! handle '@'.  the following command is @ modified, set a flag in 1.num !
! so we know to look for the alternate delimiter characters.            !
!                                                                       !
! even though <delim> characters will be specified along with the '@'   !
! command, we'll try to use ESC whenever possible and convert the @     !
! modified command back into a "normally" delimited command.            !
! --------------------------------------------------------------------- !

!@!

-1U1                                    ! set @-modified flag           !
! ...fall through ... !

! --------------------------------------------------------------------- !
! handle 'D'.  delete the character from the output file                !
! --------------------------------------------------------------------- !

!D!

-D                                      ! delete last character         !
@O!.!

! --------------------------------------------------------------------- !
! handle '1'.  we've run into ", %, G, M, Q, U, X, [, or ].  For ", the !
! next character is a conditional execution command.  For everything    !
! else, the next character is a Q-register name.  In either case, if    !
! the next char is lowercase, we uppercase it; otherwise, we fall       !
! through to the 'V' code below which simply advances past the char.    !
! --------------------------------------------------------------------- !

!1!

0A-^^."E                                ! if it's .q (local Q-reg name) !
        C                               !   advance past "."            !
'                                       ! endif                         !
0A"V                                    ! if lowercase                  !
        0A-32U0                         !   convert to uppercase        !
        D                               !   delete lowercase char       !
        Q0@I%%                          !   insert uppercase char       !
        @O!.!                           !   goto .                      !
'                                       ! endif                         !
! ... fall through ...!

! --------------------------------------------------------------------- !
! handle 'V'.  we've run into <CTRL>-^, simply skip it                  !
! --------------------------------------------------------------------- !

!V!

C                                       ! simply advance past it        !
@O!.!                                   ! goto .                        !

! --------------------------------------------------------------------- !
! handle 'C'.  we've run into an exclamation point with the /C switch   !
! set.  Q-register C contains the special comment delimiter characters. !
! --------------------------------------------------------------------- !

!C!
0A-^^! "E                               !! if alternative comment
        .UC                             !!   num C <- point
        10@^U1%%                        !!   search delim <- <LF>
|                                       !! else (normal label)
        ::@S%^EGC%"U                    !!   if not special label delim
                @O!A!                   !!     handle like ^Astring^A
        '                               !!   fi
        R                               !!   back up past special delim
        .UC                             !!   num C <- current point
        Q0@^U1%%                        !!   str 1 <- exclamation mark
        Q1"T                            !!   if @-modified
                0A@^U1%%                !!     set search delim
                D                       !!     delete delim
        '                               !!   fi
'                                       !! fi
:@S%^EQ1%"U                             ! if search for <delim> failed  !
        @O!STRINGFAIL!                  !   unterminated string         !
'                                       ! endif                         !
QC-1,.K                                 ! kill entire comment           !
0U1                                     ! clear @-modified flag         !
F<                                      ! jump to main loop             !

! --------------------------------------------------------------------- !
! handle '^'.  the next character is really CTRL-char.  we'll delete    !
! the "^char" construct, insert the "real" control char, and go back    !
! and process it again.  we'll watch out for inserting ^[ (<ESC>), we   !
! have to be careful about creating adjacent <ESC>'s.                   !
! --------------------------------------------------------------------- !

!^!

0A&31U0                                 ! 0.num = ^char                 !
C                                       ! skip past char                !
-2D                                     ! delete both ^ and char        !
QH#(Q0-27) "E                           ! if no adjacent ESC's          !
        0A-27"E                         !   if next char is ESC         !
                @I%^[%                   !     insert a single ESC       !
                C                       !     skip past next ESC        !
                F<                      !     jump to main loop         !
        '                               !   endif                       !
                ! ----------------------------------------------------- !
                ! at this point we are trying to insert an ESC; but we  !
                ! don't know if by doing so we will inadvertently form  !
                ! two adjacent escapes.  the following code searches    !
                ! backwards for the last important character (skipping  !
                ! CF/LF's) to see if that last important character was  !
                ! also an ESC.  if it was, we'll insert a <SP> to keep  !
                ! the two ESC's lexically apart.                        !
                ! ----------------------------------------------------- !
        .US                             !   S.num = cur buf ptr         !
        0UT                             !   T.num = 0                   !
        <                               ! ----loop begin--------------- !
                -.;                     !     break if .==0             !
                R                       !     back up one char          !
                0AUT                    !     T.num = previous char     !
                QT&128"E                !     if hi bit of char zero    !
                        QT-10"N               ! if char is not <LF>     !
                                0;            !   break out of loop     !
                        |                     ! else (it is <LF>)       !
                                -.;           !   break if .==0         !
                                -1A-128-13"N  !   if not <CR><LF>       !
                                        0;    !     break out of loop   !
                                '             !   endif                 !
                        '                     ! endif                   !
                '                       !     endif                     !
        >                               ! ----loop end----------------- !
        QSJ                             !     jump to where we startd   !
        QT-27"E                         !     if last char == ESC       !
                @I% %                   !       insert <SP>             !
        '                               !     endif                     !
'                                       !   endif                       !
Q0@I%%                                  ! insert ^ char                 !
@O!DISP!                                ! try again                     !

! --------------------------------------------------------------------- !
! handle 'B'.  we've run into the <LF> portion of CR/LF with the /B     !
! switch (delete blank lines) set.  if there are only two chars on the  !
! current line, assume they are CR/LF and delete them.                  !
! --------------------------------------------------------------------- !

!B!

-1^Q+2"E                                ! if only 2 chars on this line  !
        -2D                             !   delete <CR><LF>             !
'                                       ! endif                         !
F<                                      ! jump to main loop             !

! --------------------------------------------------------------------- !
! handle 'O'.  we've run into <LF>, <CR>, or <LF> with the /L switch    !
! set.                                                                  !
! --------------------------------------------------------------------- !

!O!

-D                                      ! delete last char              !
."N                                     ! if not at beginning of buffer !
        -1A&128"N                       !   if last char hi bit set     !
                -D                      !     delete it                 !
        '                               !   endif                       !
        .-1"G                           !   if 2 chars past buf begin   !
                -1A-10"E                !     if hi bi of last char set !
                        -2A-128-13"E    !       if 2nd last char = <CR> !
                                Q0-13"E !         if curr char is <CR>  !
                                        -2D !       delete <CR><CR>     !
                                |       !         else                  !
                                        F<  !       jump to main loop   !
                                '       !         endif                 !
                        '               !       endif                   !
                '                       !     endif                     !
        '                               !   endif                       !
        Q0#128@I%%                      !   insert char w/hi bit        !
        Q0-13"E                         !   if char is <CR>             !
                .-Z"E                   !     if at end of buffer       !
                        10@I%%          !       insert <LF>             !
                        R               !       back up one char        !
                '                       !     endif                     !
                0A&127-10"E             !     if curr char is <LF>      !
                        D               !       delete it               !
                '                       !     endif                     !
                10@I%%                  !   insert <LF>                 !
        '                               !   endif                       !
'                                       ! endif                         !
F<                                      ! jump to main loop             !

! --------------------------------------------------------------------- !
! handle 'U'.  we've run into ^Uq.  usually, the string ^Uq is loading  !
! into Q-register q is *not* squished.  the problem with ^Uq is that it !
! is sometimes used to load a macro into a Q-register.  This macro code !
! should be squished too.  What we do is if the ^U is @-modified, and   !
! the <delim> is *not* in the "non-squishible ^U command" character set !
! in Q-register K, we assume it is a macro and should be sub-squished.  !
! Otherwise, the ^U argument is assumed to be a simple string and is    !
! not sub-squished.                                                     !
! --------------------------------------------------------------------- !

!U!

27@^U1%%                                ! 1.str = ESC (default delim)   !
.UC                                     ! C.num = current buf ptr       !
0A-^^."E                                ! if it's .q (local Q-reg name) !
        C                               !   advance past "."            !
'                                       ! endif                         !
0A"V                                    !! if Q-reg name is lowercase
        0A-32U0                         !!   convert it to uppercase
        D                               !!   delete lowercase char
        Q0@I%%                          !!   insert uppercase char
|                                       !! else
C                                       !! advance past Q-reg name
'                                       !! fi
!! Take shortcut if text argument is empty
Q1 "T                                   !! if @-modified
        (0A-27)*                        !!   if @^Uq<delim><delim> or
        (0A-(1A)) "E                    !!     ^Uq<ESC>
                @O!$$!                  !!     goto $$
        '                               !!   fi
'                                       !! fi
.US                                     ! S.num = current buf ptr       !
Q1"T                                    !! if @-modifed
        0A@^U1%%                        !!   1.str = <delim>
        QP "T                           !!   if /P, report error for
                ::@S%^EGP% "S @O!INVLDLIM! ' !! right paren
                0A-^^( "E @^U1%)% '     !!      convert left parens
                0A-^^[ "E @^U1%]% '     !! this is the same code in !$$!
                0A-^^< "E @^U1%>% '
                0A-^^{ "E 125@^U1%% '
        '                               !!   fi
        D                               !!   delete <delim>
'                                       !! fi
@!+
:QW"N                                   ! if /W was TRUE                !
        :@S%^EQ1%"U                     !   if search for <delim> fails !
                @O!STRINGFAIL!          !     unterminated string       !
        '                               !   endif                       !
        .,4:W^[                          !   set mark status             !
        QSJ                             !   jump back to where we were  !
        MW                              !   refresh scope               !
'                                       ! endif                         !
+

! --------------------------------------------------------------------- !
! if there are no "non-squishable ^U command" characters, you used the  !
! /A:N switch.  If this is the case, we'll have to drop into "manual"   !
! mode:  everytime we run into a ^U we'll ask if you want to squish it  !
! or not, Y or N.                                                       !
! --------------------------------------------------------------------- !

:QK"E                                   ! if no non-squishable ^U delim !
@!+
        :QW"E                           !   if /W was FALSE             !
+
                0T                      !     display line up to now    !
                10^T                    !     display <LF>              !
                T                       !     display rest of line      !
@!+
        '                               !   endif                       !
        7^T                             !   display <BEL>               !
+
        ETUQ                            !   save ET flags in Q.num      !
        ET#8#4-4ET                      !   turn on read w/o echo       !
        ^TU0                            !   read char into 0.num        !
        QQET                            !   restore ET flags            !
|                                       ! else (non-squishable delims)  !
        G1                              !   put <delim> in buf          !
        R                               !   back up one char            !
        ::@S%^EGK%"S                    !   if <delim> is non-squish    !
                -D                      !     delete <delim>            !
                        ^^NU0           !     0.num = N                 !
        |                               !   else                        !
                D                       !     delete <delim>            !
                ^^YU0                   !     0.num = Y                 !
        '                               !   endif                       !
'                                       ! endif                         !
@!+
:QW"N                                   ! if /W was TRUE                !
        0,4:W^[                          !   clear "mark" status         !
        32768W                          !   set huge # of display lines !
'                                       ! endif                         !
+

! --------------------------------------------------------------------- !
! at this point, 0.num will be "Y" if we are to sub-squish the ^U text  !
! --------------------------------------------------------------------- !

Q0-^^Y"E                                ! if 0.num is Y                 !
        ! ------------------------------------------------------------- !
        ! Q-register E originally holds ".-Z" (-number of chars until   !
        ! end of the buffer, when zero we're at end of buf).  The E     !
        ! macro is executed at the top of the squish loop so we break   !
        ! out of the squish loop when we reach the end of the buf. When !
        ! we recursively sub-squish a ^U string, we want the squish     !
        ! loop to break out when it reaches the end of the ^U string.   !
        ! Therefore, we'll now load Q-register E with a macro to do so. !
        !                                                               !
        !       -1UE                    E.num == -1 (continue flag)     !
        !       0A-^^<delim>"E          if we've run into <delim>       !
        !               0UE               E.num == 0 (break flag)       !
        !       '                       endif                           !
        !       QE                      push -1 or 0 on stack           !
        ! ------------------------------------------------------------- !
        [E [C [S                        !   save Q-reg's E, C, & S      !
        @^UE%-1UE0A-^^%                 !   load Q-reg E w/macro start  !
        0Q1:@^UE%%                      !   append <delim> to Q-reg E   !
        :@^UE%"E0UE'QE%                 !   append macro end to Q-reg E !
        MZ                              !   squish recursively          !
        ]S ]C ]E                        !   restore Q-reg's C, S & E    !
        "N                              !   if recursive MZ failed      !
                @O!PRIORFAIL!           !     announce it               !
        '                               !   endif                       !
        C                               !   advance past end ^U delim   !
        @O!$$$$!                        !   goto $$$$                   !
'                                       ! endif                         !
@O!$$$!                                 ! goto $$$                      !

! --------------------------------------------------------------------- !
! handle 'T'.  we've run into a TAB character, start an insert.         !
! --------------------------------------------------------------------- !

!T!

0U1                                     ! clear @-modified flag         !

! --------------------------------------------------------------------- !
! handle '$'.  we've run into I, N, O, or S: commands which take a      !
! single string argument (ie: commands which contain one <delim>).      !
! --------------------------------------------------------------------- !

!$!

27@^U1%%                                ! 1.str = ESC (default delim)   !
.UC                                     ! C.num = current buf ptr       !

!! ---------------------------------------------------------------------
!! $$, entry point for two char commands take one string arguments (ie:
!! F commands and E commands).
!! ---------------------------------------------------------------------

!$$!

.US                                     ! S.num = start of text         !
Q1"T                                    ! if @-modified                 !
        0A@^U1%%                        !   1.str = <delim>             !
        QP "T                           !!   if /P, report error for
                ::@S%^EGP% "S @O!INVLDLIM! ' !! right curly brackt
                0A-^^( "E @^U1%)% '     !!      right ...
                0A-^^[ "E @^U1%]% '
                0A-^^< "E @^U1%>% '
                0A-^^{ "E 125@^U1%% '
        '                               !!   fi
        D                               !   delete <delim>              !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! $$$, entry point for the ^U routine when we are not sub-squishing the !
! ^U argument, but we've already handled being @-modified.              !
! --------------------------------------------------------------------- !

!$$$!

:@S%^EQ1%"U                             ! if search for <delim> fails   !
        @O!STRINGFAIL!                  !   unterminated string         !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! $$$$, entry point for the ^U routine after we've sub-squished a ^U    !
! macro.                                                                !
! --------------------------------------------------------------------- !

!$$$$!

-D                                      ! delete trailing <delim>       !
.UT                                     ! T.num = end of text           !
27U0                                    ! 0.num = ESC (default <delim>  !

! --------------------------------------------------------------------- !
! At this point, we have to output a delimited string.                  !
!                                                                       !
!       0.num = <delim>                                                 !
!       C.num = start of command                                        !
!       S.num = start of text                                           !
!       T.num = end of text                                             !
!                                                                       !
! --------------------------------------------------------------------- !

!AA!

Q0@^U0%%                                ! 0.str = <delim> char          !
QT-QS"G                                 ! if string is not-empty        !
        QSJ                             !   jump to start of string     !
        .,.+QT-QS:@FB%^EQ0%"S           !   if <delim> is in string     !
                ! ----------------------------------------------------- !
                ! find a <delim> we can use, one which is *not* already !
                ! in the string.                                        !
                ! ----------------------------------------------------- !
                G8                      !     put 8.str into buf        !
                ^YX1                    !     put 8.str into 1.str      !
                ^YK                     !     kill 8.str from buf       !
                0U0                     !     clear 0.num               !
                <                       ! ----loop begin--------------- !
                        Q0Q1@^U0%%      !       0.str = Q0th char of Q1 !
                        QSJ             !       jump to start of text   !
                        .,.+QT-QS@FB%^EQ0%; !   break if search fails   !
                        %0-:Q8"E        !       if next char last char  !
                                @O!NOQUOTE!     ! can't find " char     !
                        '               !       endif                   !
                >                       ! ----loop end----------------- !
                Q0Q1U0                  !     0.num = <delim> to use    !
                QSJ                     !     jump to start of string   !
                Q0@I%%                  !     insert <delim>            !
                QP "T                   !!    if /P
                        Q0-^^) "E -D @I%(% ' !! replace pair delimiters
                        Q0-^^] "E -D @I%[% '
                        Q0-^^> "E -D @I%<% '
                        Q0-125 "E -D @I%{% '
                '                       !!    fi
                QC-1J                   !     jump before command       !
                @I%@%                   !     insert @                  !
                2%T^[                    !     T.num (end of text) += 2  !
                ! ----------------------------------------------------- !
        '                               !   endif                       !
'                                       ! endif                         !
QTJ                                     ! jump to end of string         !
Q0@I%%                                  ! insert <delim>                !
0U1                                     ! clear @-modified flag         !
F<                                      ! jump to main loop             !

! --------------------------------------------------------------------- !
! handle 'F'.  we've run into a F', F<. F>, F|, FB, FC, FD, FK, FN, FR, !
! FS, or F_ command.                                                    !
! --------------------------------------------------------------------- !

!F!

27@^U1%%                                ! 1.str = ESC (default delim)   !
.UC                                     ! C.num = current buf ptr       !
0AU0                                    ! 0.num = 2nd command char      !
C                                       ! advance past 2nd cmd char     !
Q0"V                                    ! if 2nd cmd char is lowercase  !
        Q0-32U0                         !   convert it to uppercase     !
        -D                              !   delete lowercase char       !
        Q0@I%%                          !   insert uppercase char       !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! the FB, FD, FR, FK commands take a single string argument, goto $$    !
! the FC, FS, FN, and F_ commands take two string arguments, fall to    !
! next case.                                                            !
! --------------------------------------------------------------------- !

(Q0==^^B#Q0==^^D#Q0==^^K#Q0==^^R) "T
        @O!$$!
'
(Q0==^^C#Q0==^^S#Q0==^^N#Q0==^^_) "F
        @O!.!
'

! --------------------------------------------------------------------- !
! handle FC, FS, FN, and F_ commands which take two string arguments,   !
! there are three possible formats for these commands:                  !
!                                                                       !
!       Fx <delim> <delim>                                              !
!       Fx text <delim> <delim>                                         !
!       Fx text1 <delim> text2 <delim>                                  !
!                                                                       !
! we first have to find the starting and ending points of the text      !
! arguments.  we set S.num to be the start of text1, we look for the    !
! 1st <delim>, delete it, and set T.num to be the start of text2.  we   !
! then look for the 2nd <delim>, delete it, and set U.num to be the     !
! end of text2.                                                         !
!                                                                       !
! if S.num == T.num & T.num == U.num, then we have: FS$$                !
! if S.num <> T.num & T.num == U.num, then we have: FStext$$            !
! if S.num <> T.num & T.num <> U.num, then we have: FStext1$text2       !
! --------------------------------------------------------------------- !

!! For TECO-64 the paired delmiter syntax is
!! @FS[text1][text2]

.US                                     ! S.num = start of text1        !
Q1"T                                    !! if @-modified
        @^U1%%                          !!   clear str 1
        QP "T                           !!   if /P
                ::@S%^EGP% "S @O!INVLDLIM! ' !! check invalid delim
                0A-^^( "E @^U1%)% '     !!     setup delim in between
                0A-^^[ "E @^U1%]% '
                0A-^^< "E @^U1%>% '
                0A-^^{ "E 125@^U1%% '
        '                               !!   fi
        0A:@^U1%%                       !!   append <delim> to str 1
        D                               !!   delete <delim>
|                                       !! else
        27@^U1%%                        !!   1.str = ESC (default delim)
'                                       !! fi
:@S%^EQ1%"U                             !! if search for 1st delim fails
        @O!STRINGFAIL!                  !!   unterminated string
'                                       !! fi
-D                                      !! delete 1st <delim>
QP "T                                   !! if /P
        :Q1-2 "E                        !!   if used pair delim
        -D                              !!     delete again
        0Q1@^U1%%                       !!     str 1 <- first of str 1
        '                               !!   fi
'                                       !! fi
.UT                                     !! T.num = start of text2
:@S%^EQ1%"U                             !! if search for 2nd delim fails
        @O!STRINGFAIL!                  !!   unterminated string
'                                       !! fi
-D                                      !! delete 2nd <delim>
.UU                                     ! U.num = end of text2          !
QH"T                                    ! if allow adjacent escapes     !
        27U0                            !   0.num = ESC                 !
        Q0@^U0%%                        !   0.str = ESC                 !
        QU-QS"G                         !   if we have text1 & text2    !
                QSJ                     !     jump to start of text1    !
                .,.+QU-QS:@FB%^EQ0%"U   !     if search for ESC fails   !
                        @O!F0!          !       use ESC as <delim>      !
                '                       !     endif                     !
        |                               !   else (no text arguments)    !
                @O!F0!                  !     use ESC as DELIM          !
        '                               !   endif                       !
|                                       ! else (don't allow adjacent $) !
        QU-QT"G                         !   if we have text2            !
                27U0                    !     0.num = ESC               !
                Q0@^U0%%                !     0.str = ESC               !
                QSJ                     !     jump to start of text1    !
                .,.+QU-QS:@FB%^EQ0%"U   !     if search for ESC fails   !
                        @O!F0!          !       done w/F                !
                '                       !     endif                     !
        '                               !   endif                       !
'                                       ! endif                         !

! --------------------------------------------------------------------- !
! if we reach this point, there is a danger of putting adjacent ESC's   !
! in the output.  we will try to find a character that's not in the     !
! string we're delimiting and use that as a <delim> character instead   !
! of ESC.  basically, we search "text1text2" looking for each character !
! in G8, trying to find a delimiter char that's not already in the      !
! string.                                                               !
! --------------------------------------------------------------------- !

G8                                      ! put 8.str into buf            !
^YX1                                    ! put 8.str into 1.str          !
^YK                                     ! kill 8.str from buf           !
0U0                                     ! 0.num = 0                     !
<                                       ! loop begin------------------- !
        Q0Q1@^U0%%                      !   0.str = 0.num'th char of Q1 !
        QSJ                             !   jump to start of text1      !
        .,.+QU-QS@FB%^EQ0%;             !   break if 0.str search fails !
        %0-:Q8"E                        !   inc 0.num, if end of 8.str  !
                @O!NOQUOTE!             !     can't find " char         !
        '                               !   endif                       !
>                                       ! loop end--------------------- !

! --------------------------------------------------------------------- !
! at this point, we've found our <delim> char, it's index is in 0.num   !
! --------------------------------------------------------------------- !

Q0Q1U0                                  ! 0.num = Q0th char of Q1       !
QSJ                                     ! jump to start of text1        !
Q0@I%%                                  ! insert <delim>                !
QP "T                                   !! if /P
        Q0-^^) "E -D @I%(% '            !!   replace pair delimiters
        Q0-^^] "E -D @I%[% '
        Q0-^^> "E -D @I%<% '
        Q0-125 "E -D @I%{% '
'                                       !! fi
QC-1J                                   ! jump 1 char before F command  !
@I%@%                                   ! insert @                      !
2%T^[                                    ! T.num (end of text1) += 2     !
2%U^[                                    ! U.num (end of text2) += 2     !

!F0!

QTJ                                     ! jump to end of text1          !
Q0@I%%                                  ! insert <delim>                !
QP "T                                   !! if /P
        Q0-^^) "E @I%(% '               !!   insert additional
        Q0-^^] "E @I%[% '               !!    pair delimiters
        Q0-^^> "E @I%<% '
        Q0-125 "E @I%{% '
'                                       !! fi
QU-QTC                                  ! advance to end of text2       !
Q0@I%%                                  ! insert <delim>                !
0U1                                     ! clear @-modified flag         !
F<                                      ! jump to main loop             !

!! ---------------------------------------------------------------------
!! handle 'A'.  we've run into ^Atext^A or @^A/text/.  This is also the
!! entry point for the 'C' routine:  if we're not deleting the comment
!! we handle !commen! just like ^Atest^A.
!! ---------------------------------------------------------------------

!A!

Q0@^U1%%                                ! 1.str = ^A or exclamation pt. !
.UC                                     ! C.num = start of text         !
.US                                     ! S.num = start of text         !
Q1"T                                    ! if @-modified                 !
        0A@^U1%%                        !   1.str = <delim>             !
        D                               !   delete <delim>              !
'                                       ! endif                         !
:@S%^EQ1%"U                             ! if search for <delim> fails   !
        @O!STRINGFAIL!                  !   unterminated string         !
'                                       ! endif                         !
-D                                      ! delete second <delim>         !
.UT                                     ! T.num = end of text           !
@O!AA!                                  ! goto AA                       !

! --------------------------------------------------------------------- !
! handle 'E'.  we've run into an E command.                             !
! --------------------------------------------------------------------- !

!E!

27@^U1%%                                ! 1.str = ESC (default delim)   !
.UC                                     ! C.num = current buf ptr       !
0AU0                                    ! 0.num = 2nd command char      !
C                                       ! advance past 2nd cmd char     !
Q0"V                                    ! if 2nd cmd char is lowercase  !
        Q0-32U0                         !   convert to uppercase        !
        -D                              !   delete lowercase char       !
        Q0@I%%                          !   insert uppercase char       !
'                                       ! endif                         !

!! ---------------------------------------------------------------------
!! the EB, EG, EI, EL, EN, ER, EW, EZ, E_ commands take a string argument,
!! they have to be passed to the $$ routine.
!! ---------------------------------------------------------------------

(Q0==^^B#Q0==^^G#Q0==^^I#Q0==^^L#Q0==^^N#
Q0==^^R#Q0==^^W#Q0==^^Z#Q0==^^_) "T
        @O!$$!
'
(Q0==^^Q#Q0==^^%) "F
        @O!.!
'

!! Handle EQq, E%q that takes one string argument.

0A-^^."E                                !! if it's .q (local Q-reg name)
        C                               !!   advance past "."
'                                       !! fi
0A"V                                    !! if Q-reg name is lowercase
        0A-32U0                         !!   convert it to uppercase
        D                               !!   delete lowercase char
        Q0@I%%                          !!   insert uppercase char
|                                       !! else
C                                       !! advance past Q-reg name
'                                       !! fi
@O!$$!

! --------------------------------------------------------------------- !
! handle 'Z'.  we've run into a ^Z, replace it with <CARET>-Z           !
! --------------------------------------------------------------------- !
@!+
!Z!     !! disabled because TECO-64 does not suspend on literal ^Z

-D                                      ! delete <CTRL>-Z               !
@I%^Z%                                  ! insert <CARET>-Z              !
F<                                      ! jump to main loop             !
+

>                                       ! main loop end---------------- !

! --------------------------------------------------------------------- !
! At this point, everything should be squished and Q1 will be -1 if     !
! an error occurred, or 0 if everything is OK.                          !
! --------------------------------------------------------------------- !

Q1"T                                    ! if error flag                 !
        @^U1%Trailing, pending @%       !                               !
        @O!ERROR!                       !   goto error display          !
'                                       ! endif                         !
0U1                                     ! clear Z-macro return value    !

! --------------------------------------------------------------------- !
! the only way the following error reporting code is executed is if we  !
! jump to a label inside of it.  if we arrive here by any other means   !
! then things are OK, skip down to the "endif".                         !
! --------------------------------------------------------------------- !

0"N                                     ! skip the following code       !
!OFFEND!
        @^U1%End of buffer while sub-squishing%
        @O!ERROR!

!NOQUOTE!
        @^U1%Can't find a quote character%
        @O!SETPOS!

!PRIORFAIL!
        @^U1%Prior recursion level failed%
        @O!SETPOS!

!INVLDLIM!
        @^U1%Invalid delimter%
        @O!SETPOS!

!STRINGFAIL!
        @^U1%Unterminated string%

! --------------------------------------------------------------------- !
! the following code finishes building an error string in Q-register 1. !
! 1.str already contains the type of error, this code appends the       !
! position where the error occurred and the line before and after the   !
! error, like so:                                                       !
!                                                                       !
!       <error message> from squished .=<error position>                !
!       <line up to error>|                                             !
!                          |<line after error>                          !
!                                                                       !
! --------------------------------------------------------------------- !

!SETPOS!
        :@^U1% from squished .=%        !   append msg to 1.str         !
        QC\                             !   position in C.num to buf    !
        ^Y:X1                           !   append position in buf      !
        ^YK                             !   delete position from buf    !
        13:@^U1%%                       !   append <CR>                 !
        10:@^U1%%                       !   append <LF>                 !
        QCJ                             !   jump to where error starts  !
        0^Q+.,.:X1                      !   append line up to error     !
        ^^|:@^U1%%                      !   append |                    !
        10:@^U1%%                       !   append <LF>                 !
        ^^|:@^U1%%                      !   append |                    !
        .,^Q+.:X1                       !   append rest of line         !

!ERROR!
        ZJ                              !  jump to buf end              !
@!+
        MW                              !  refresh scope                !
        0,0XW                           !  clear W.str (/W switch)      !
        7^T                             !  sound bell                   !
+
        ^^?^T                           !  display "?"                  !
        :G1                             !  display 1.str                !
@!+
        7^T                             !  sound bell                   !
+
        13^T                            !  display <CR>                 !
        10^T                            !  display <LF>                 !
        -1U1                            !  set Z-macro return to -1     !
'                                       ! endif                         !
Q1                                      ! push Z-macro return val       !
]1                                      ! restore Q-reg 1               !
}                                       !! end of ^UZ

!! Done loading squisher macro into Q-register Z

!! Load squish driver macro into Q-register A

@^UA{                                   !! str A <- squish driver macro
-1^X                                    ! search flag = exact matches   !
@^UE%.-Z%                               ! E.str = -# chars to buf end   !
QO"N                                    ! if max line length not 0      !
        ZJ                              !   jump buf end                !
        @I% %                           !   insert <SP>, insure we halt !
'                                       ! endif                         !
J                                       ! jump to beginning of buffer   !
MZ"E                                    ! if squish macro returns OK    !
        ! ------------------------------------------------------------- !
        ! at this point, everything is squished; but, if the /L switch  !
        ! was set, we've deleted all lexical CR/LF's and have to go     !
        ! back and insert CR/LF wherever needed so the line is no       !
        ! longer than the width specified with /L:nn.                   !
        ! ------------------------------------------------------------- !
        QO"N                            !   if max line length not 0    !
                :QW"N                   !     if /W was TRUE            !
                        -1,3:W^[         !       turn on SEEALL mode     !
                        0,4:W^[          !       clear "mark" status     !
                        0,5:W^[          !       turn off hold mode      !
                '                       !     endif                     !
                J                       !     jump to beginning of buf  !
                <                       ! ----loop begin--------------- !
@!+
                        MW              !       refresh scope           !
+
                        ! --------------------------------------------- !
                        ! the following loop advances through the edit  !
                        ! buffer, looking for a character with the high !
                        ! bit set.                                      !
                        ! --------------------------------------------- !
                        <               ! ------loop begin------------- !
                                0A&128"N        ! if high bit is set    !
                                        0;      !   break out of loop   !
                                '               ! endif                 !
                                C       !         advance 1 char        !
                        >               ! ------loop end--------------- !
                        0A&127-13"E     !       if char is <CR>         !
                                D       !         delete it             !
                        '               !       endif                   !
                        D               !       delete <LF>             !
                        .-Z;            !       break if at end of buf  !
                        .U0             !       0.num = current buf ptr !
                        ! --------------------------------------------- !
                        ! --------------------------------------------- !
                        <               ! ------loop begin------------- !
                                0A&128"N        ! if hi bit clear       !
                                        0;      !   break out of loop   !
                                '               ! endif                 !
                                C       !         advance 1 char        !
                        >               ! ------loop end--------------- !
                        ! --------------------------------------------- !
                        ! --------------------------------------------- !
                        <               ! ------loop begin------------- !
                                .U1     !         1.num = cur buf ptr   !
                                0L      !         go to begin of line   !
                                .-Q0-1"L        ! if                    !
                                        0;      !   break out of loop   !
                                '               ! endif                 !
                                R       !         back up one char      !
                        >               ! ------loop end--------------- !
                        Q1J
                        -(0^Q)-QO"G     !       if                      !
                                Q0J     !                               !
                                -1A-27"E        ! if last char was ESC  !
                                        @I% %   !   insert <SP>         !
                                '               ! endif                 !
                                13@I%% 10@I%%
                                        !       insert <CR><LF>         !
                        '               !       endif                   !
                >                       ! ----loop end----------------- !
                ! ----------------------------------------------------- !
                ! the following loop deletes trailing CR's, LF's, and   !
                ! <SP>'s from the end of the buffer                     !
                ! ----------------------------------------------------- !
                <                       ! ----loop begin--------------- !
                        ZJ              !       jump to buf end         !
                        -Z;             !       break if buf empty      !
                        -1A-10"N        !       is it LF?               !
                                -1A-13"N        ! is it CR?             !
                                        -1A-32"N        !   is it <SP>? !
                                                0;      !     break     !
                                        '               !   endif       !
                                '               ! endif                 !
                        '               !       endif                   !
                        -D              !       delete it               !
                >                       ! ----loop end----------------- !
@!+
                MW                      !     refresh scope             !
+
        '                               !   endif                       !
        ! ------------------------------------------------------------- !
        ! make sure the edit buffer ends in a CR/LF.                    !
        ! ------------------------------------------------------------- !
        QH"F                            !   if no adjacent escapes      !
                ZJ                      !     jump to buf end           !
                ."E                     !     if at beginning of buf    !
                        10@I%%          !       insert <LF>             !
                '                       !     endif                     !
                -1A-10"N                !     if prev char is not <LF>  !
                        10@I%%          !       insert <LF>             !
                '                       !     endif                     !
                R                       !     back up one char          !
                ."E                     !     if at beginning of buf    !
                        13@I%%          !       insert <CR>             !
                '                       !     endif                     !
                -1A-13"N                !     if prev char is not <CR>  !
                        13@I%%          !       insert <CR>             !
                '                       !     endif                     !
        '                               !   endif                       !
        ZJ                              !   jump to buf end             !
@!+
        ! ------------------------------------------------------------- !
        ! clean up the scope                                            !
        ! ------------------------------------------------------------- !
        :QW"N                           !   if /W was TRUE              !
                0:W-4"E                 !     if VT100 in ANSI mode     !
                        2,0:W^[          !       set VT100 in VT52 mode  !
                '                       !     endif                     !
                -1,3:W^[                 !     turn on SEEALL mode       !
                0,4:W^[                  !     clear "mark" status       !
                MW                      !     refresh scope             !
        '                               !   endif                       !
+
|                                       ! else (Z macro returned err)   !
        :@^A/?Squish run failed; aborting any output/
        0,0XF                           !   clear F.str                 !
'                                       ! endif                         !
0^X                                     ! reset search mode flag        !
}                                       !! end of ^UA

!! Done loading squish driver macro into Q-register A

!! If nothing is in the edit buffer, as them to input the name of the
!! input file and insert it into the buffer.

Z"E                                     ! if edit buffer is empty       !
        @I%File <.TES or .TEC>? %       !   ask for input file          !
        MR                              !   get response in Q.str       !
        GQ                              !   and put it into the buffer  !
'                                       ! endif                         !
0,0XR                                   ! clear R.str (response macro)  !
0,0XQ                                   ! clear Q.str (user responses)  !
                                       !! End of ^UF

!! START HERE

MF      !! execute initialization
0,0XF   !! clear macro F

Z "E                    !! if no file arguments
        :@^A%Enter your macro then type MA``%
|                       !! else
        ! ------------------------------------------------------------- !
        ! If the edit buffer isn't empty, it must contain the input     !
        ! filename, and it might contain the output filename like so:   !
        !                                                               !
        !       [OUTFILE[.TEC]=]INFILE[.TES]                            !
        !                                                               !
        ! Executing the F macro above has stripped all the switches     !
        ! from the command line in the edit buffer.                     !
        !                                                               !
        ! First, deal with an output filename.  If an output filename   !
        ! exists on the command line, we might append a .TEC filetype   !
        ! to it if a filetype wasn't specified.  Then we'll load Q-reg  !
        ! F with "EWfilename$" to open it for output and remove the     !
        ! output filename from the buffer.                              !
        ! ------------------------------------------------------------- !

        J                               ! jump to start of buffer       !
        :@FS%=%%"S                      ! if "=" found, have output fn  !
                @^UF%EW%                !   put "EW" in F.str           !
                0,.:XF                  !   append fn to F.str          !
                .UF                     !   put cp in F.num             !
                -:@S%.%"U               !   if no ".", no file type     !
                        :@^UF%.TEC%     !     append ".TEC"             !
                '                       !   endif                       !
                QFJ                     !   jump to end of filename     !
                27:@^UF%%               !   append ESC to F.str         !
                QB"T                    !   if any switches             !
                        ET&64"E         !     if not detached           !
                                :@^UF{  !       append create msg to F  !
                                @^A%Creating "%
                                :G*     !       append last filespec    !
                                :@^A%%  !       append "<CR><LF>        !
                                }       !       done loading F.str      !
                        '               !     endif                     !
                '                       !   endif                       !
                0,.K                    !   kill output fn in buffer    !
        '                               ! endif                         !

        ! ------------------------------------------------------------- !
        ! Now, deal with an input filename.  If the filename doesn't    !
        ! have a filetype, first we'll try .TES; and, if there is no    !
        ! .TES file, we'll try .TEC.  Once we have an input filename,   !
        ! we'll ER it.                                                  !
        ! ------------------------------------------------------------- !
        J                               ! jump to start of buf          !
        :@S%.%"U                        ! if no ".", no filetype        !
                ZJ                      !   jump to buf end             !
                @I%.TES%                !   insert ".TES"               !
                HXQ                     !   put input fn in Q.str       !
                :@ER%^EQQ%"U            !   if ".TES" doesn't exist     !
                        -@FS%.TES%.TEC% !     try ".TEC"                !
                '                       !   endif                       !
        '                               ! endif                         !
        HXQ                             ! Q.str = input filename        !
        HK                              ! kill buffer                   !
        @ER%^EQQ%                       ! open input file               !
        QB"T                            ! if any switches               !
                ET&64"E                 !   if not detached             !
                        @^A%Squishing "%!     display squish message"   !
                        :G*             !     display filespec buffer   !
                        :@^A%%          !     display "<CR><LF>         !
                '                       !   endif                       !
        '                               ! endif                         !

        ! ------------------------------------------------------------- !
        ! If there's no output filename, we'll stay in TECO after       !
        ! squishing the input file.  If there is an output file, we'll  !
        ! exit TECO after squishing.                                    !
        ! ------------------------------------------------------------- !

        :QF"E                           ! if no output filename         !
                Y                       !   yank 1st page               !
                128,0ET                 !   turn off abort-on-error     !
                <                       ! ----loop begin--------------- !
                        ^E"T            !     if formfeed flag          !
                                ZJ      !       jump to buf end         !
                                12@I%%  !       insert <FF>             !
                        '               !     endif                     !
                        :A;             !     break if append fails     !
                >                       ! ----loop end----------------- !
                MA                      !   squeeze page                !
        |                               ! else (we have an output fn)   !
                Y                       !   yank 1st page               !
                QB"F                    !   if no switches              !
                        128,0ET         !     turn off abort-on-error   !
                '                       !   endif                       !

                ! ----------------------------------------------------- !
                ! if we're at end-of-file after yanking in the first    !
                ! page, then squeeze what we've read in and write it    !
                ! out.  If we're not at end-of-file, then we'll have    !
                ! to go into a loop: squeezing the page we have, and    !
                ! then reading in the next page.                        !
                ! ----------------------------------------------------- !

                ^N "T                   !   if at end-of-file           !
                        ^E"T            !     if formfeed flag          !
                                ZJ      !       jump to buf end         !
                                12@I%%  !       insert <FF>             !
                        '               !     endif                     !
                        MA              !     squeeze page              !
                        MF              !     open output file          !
                        HPW             !     write page                !
                        HK              !     kill page                 !
                |                       !   else                        !
                        MF              !     open output file          !
                        <               ! ------loop begin------------- !
                        ^E"T            !     if formfeed flag          !
                                ZJ      !       jump to buf end         !
                                12@I%%  !       insert <FF>             !
                        '               !     endif                     !
                        MA              !     squeeze current page      !
                        HPW             !     write current page        !
                        HK              !     kill current page         !
                        :Y;             !     break if yank fails       !
                        >               ! ------loop end--------------- !
                '                       !   endif                       !
                EF                      !   close output file           !
                EX                      !   exit                        !
        '                               !   endif                       !
'                                       !! fi

^[^[
